{-# OPTIONS -Wall #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  ZMidi.Emit.OutputMidi
-- Copyright   :  (c) Stephen Tetley 2010
-- License     :  BSD3
--
-- Maintainer  :  stephen.tetley@gmail.com
-- Stability   :  unstable
-- Portability :  GHC
--
-- ...
--
--------------------------------------------------------------------------------

module ZMidi.Emit.OutputMidi
  (
    writeZMidiRep
  ) where

import ZMidi.Emit.Datatypes
import ZMidi.Emit.Utils.HList
import qualified ZMidi.Emit.Utils.JoinList as JL

import ZMidi.Core                               -- package: zmidi-core

import Control.Applicative
import Control.Monad
import Data.List
import qualified Data.IntMap as IM
import Data.Time
import Data.Word





-- Note - this is a Double so it is the right type for calculating
-- durations, in MIDI files the size of the ticks-per-beat 
-- designator is actually a Word16.
--
ticks_per_quarternote :: Double
ticks_per_quarternote = 480

durationr :: Double -> Word32
durationr r = floor $ (4 * ticks_per_quarternote) * r


--------------------------------------------------------------------------------

-- Note - the state tracks absolute time, conversion to delta time 
-- is performed as a traversal afterwards

data RState = RState
      { rs_volume               :: Word8
      , rs_ellapsed_time        :: Word32
      }

zeroRS :: RState
zeroRS = RState { rs_volume          = 127
                , rs_ellapsed_time   = 0
                }

newtype REnv = REnv { re_chan_number         :: Int }


newtype OutMonad a = OutMonad { 
          getOutMonad :: REnv -> RState -> (a,RState) }


instance Functor OutMonad where
  fmap f mf = OutMonad $ \r s -> let (a,s1) = getOutMonad mf r s in (f a,s1)

instance Applicative OutMonad where
  pure a    = OutMonad $ \_ s -> (a,s)
  mf <*> ma = OutMonad $ \r s -> let (f,s1) = getOutMonad mf r s
                                     (a,s2) = getOutMonad ma r s1
                                 in (f a,s2)

instance Monad OutMonad where
  return a  = OutMonad $ \_ s -> (a,s)
  m >>= k   = OutMonad $ \r s -> let (a,s1) = getOutMonad m r s
                                 in (getOutMonad . k) a r s1
                              

runOutMonad :: Int -> OutMonad a -> a
runOutMonad track_num mf = fst $ getOutMonad mf (REnv track_num) zeroRS


getsRS :: (RState -> a) -> OutMonad a
getsRS fn = OutMonad $ \_ s -> (fn s,s)


setsRS :: (RState -> RState) -> OutMonad ()
setsRS fn = OutMonad $ \_ s -> ((),fn s)

asksRE :: (REnv -> a) -> OutMonad a
asksRE fn = OutMonad $ \e s -> (fn e,s)



incrEllapsedTime :: Word32 -> OutMonad ()
incrEllapsedTime n = 
    setsRS (\s -> let i = rs_ellapsed_time s in s { rs_ellapsed_time = i+n})


getEllapsedTime     :: OutMonad Word32
getEllapsedTime     = getsRS rs_ellapsed_time

askChannelNumber    :: OutMonad Word8
askChannelNumber    = fmap fromIntegral $ asksRE re_chan_number


-- Nice to have time stamp ....


writeZMidiRep :: FilePath -> ZMidiRep -> IO ()
writeZMidiRep filename mct = 
    getZonedTime >>= \ztim -> writeMidi filename (outputZMR ztim mct)



outputZMR :: ZonedTime -> ZMidiRep -> MidiFile
outputZMR ztim (ZMidiRep ts) = 
    MidiFile hdr $ infoTrack ztim : JL.zipWithIntoList fn ts [1..]
  where
    fn  = flip outputAudioTrack
    hdr = MidiHeader MF1 len tpb
    len = fromIntegral $ 1 + JL.length ts
    tpb = TPB $ floor ticks_per_quarternote


infoTrack :: ZonedTime -> MidiTrack
infoTrack ztim = MidiTrack $ 
    [ genericText "Generated by ZMidi."
    , genericText $ midiTimeStamp ztim
    , sequenceName "Track 0"
    , end_of_track
    ]


genericText :: String -> MidiMessage
genericText ss = (0, MetaEvent $ TextEvent GENERIC_TEXT ss)

sequenceName :: String -> MidiMessage
sequenceName ss = (0, MetaEvent $ TextEvent SEQUENCE_NAME ss)



microseconds_per_minute :: Double
microseconds_per_minute = 60000000


-- programChange :: Word8 -> Word8 -> MidiMessage
-- programChange inst ch = (0, VoiceEvent $ ProgramChange ch inst)

outputAudioTrack :: Int -> AudioTrack -> MidiTrack
outputAudioTrack track_num (AudioTrack im) = 
    MidiTrack $ info : collapseChannels (IM.toAscList im)
  where 
    info = sequenceName $ "Track" ++ show track_num


collapseChannels :: [(Int,ChannelStream)] -> [MidiMessage]
collapseChannels xs = deltaTransform $ concatMessages all_chans
  where
    all_chans = map (uncurry outputChannelStream) xs

outputChannelStream :: Int -> ChannelStream -> [MidiMessage]
outputChannelStream ch strm = 
    post $ runOutMonad ch $ JL.toListM outputSection $ getSections strm
  where
    post = toListH . concatH



type HChannelData = H MidiMessage


outputSection  :: Section -> OutMonad HChannelData
outputSection (Section tmpo jl) = do
    front <- setTempo tmpo
    rest  <- JL.toListM voiceData jl
    return $ front `consH` concatH rest



concatMessages :: [[MidiMessage]] -> [MidiMessage]
concatMessages []     = []
concatMessages [x]    = x
concatMessages (x:xs) = foldl' (mergeOrdered cmp) x xs
  where
    cmp (d1,_) (d2,_) = d1 `compare` d2


mergeOrdered :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
mergeOrdered cmp = step
  where
    step []     ys      = ys
    step xs     []      = xs
    step (x:xs) (y:ys)  = case cmp x y of
                            LT -> x : step xs (y:ys)
                            EQ -> x : y : step xs ys
                            GT -> y : step (x:xs) ys

-- Upto the onset time merge, messages are labelled with absolute 
-- time rather than delta time.
--
-- This transforms them to use delta time.
--
deltaTransform :: [MidiMessage] -> [MidiMessage]
deltaTransform = step 0
  where
    step _    []              = [end_of_track]
    step abst ((evt,body):xs) = (evt - abst,body) : step evt xs



end_of_track :: MidiMessage
end_of_track = (0, MetaEvent $ EndOfTrack)



voiceData :: SectionVoice -> OutMonad HChannelData
voiceData (SectionVoice xs) = primitives xs 


primitives :: [MidiPrim] -> OutMonad HChannelData
primitives []     = return emptyH
primitives (x:xs) = step x xs
  where
    step a []     = primitive a
    step a (b:bs) = liftA2 appendH (primitive a) (step b bs)

primitive :: MidiPrim -> OutMonad HChannelData
primitive (PNote d props p)   = primNote (durationr d) props p
primitive (PChord d props ps) = primChord (durationr d) props ps
primitive (PRest d)           = incrEllapsedTime (durationr d) >> return emptyH
primitive (PMsg msg)          = either voiceMsg metaEvent msg


primNote :: Word32 -> PrimProps -> Word8 -> OutMonad HChannelData
primNote d props p = do 
    et <- getEllapsedTime
    ch <- askChannelNumber
    incrEllapsedTime d
    let non = mkNoteOn  et     p ch (velocity_on props)
    let nof = mkNoteOff (et+d) p ch (velocity_off props)
    return (twoH non nof)


primChord :: Word32 -> PrimProps -> [Word8] -> OutMonad HChannelData
primChord d props ps  = do 
    et <- getEllapsedTime
    ch <- askChannelNumber
    incrEllapsedTime d
    let nons = map (\p -> mkNoteOn  et     p ch (velocity_on props))  ps
    let nofs = map (\p -> mkNoteOff (et+d) p ch (velocity_off props)) ps
    return (fromListH nons `appendH` fromListH nofs)


voiceMsg :: VoiceMsg -> OutMonad HChannelData
voiceMsg f = do
    et <- getEllapsedTime
    ch <- askChannelNumber
    return $ wrapH $ (et, VoiceEvent $ getVoiceMsg f ch)
             


metaEvent :: MidiMetaEvent -> OutMonad HChannelData
metaEvent evt = do
    et <- getEllapsedTime
    return $ wrapH (et, MetaEvent evt) 

mkNoteOn :: Word32 -> Word8 -> Word8 -> Word8 -> MidiMessage
mkNoteOn dt pch ch vel = (dt, VoiceEvent $ NoteOn ch pch vel)

mkNoteOff :: Word32 -> Word8 -> Word8 -> Word8 -> MidiMessage
mkNoteOff dt pch ch vel = (dt, VoiceEvent $ NoteOff ch pch vel)


setTempo :: Double -> OutMonad MidiMessage
setTempo bpm = do 
    et <- getEllapsedTime
    return (et, MetaEvent $ SetTempo mspqn) 
  where
    mspqn = floor $ microseconds_per_minute / bpm


--------------------------------------------------------------------------------


-- | To be used with getZonedTime

midiTimeStamp :: ZonedTime -> String
midiTimeStamp zt = bodyS [] 
  where
    bodyS       = localTimeS . showChar ' ' . localDayS
    local_tim   = zonedTimeToLocalTime zt
    localTimeS  = timeOfDay  $ localTimeOfDay $ local_tim
    localDayS   = showString $ showGregorian  $ localDay local_tim

timeOfDay :: TimeOfDay -> ShowS
timeOfDay t = 
    fn todHour . showChar ':' . fn todMin . showChar ':' . fn (floori . todSec)
  where
    fn f = pad2 (f t) 


pad2 :: Int -> ShowS
pad2 i | i < 10    = ('0':) . shows i
       | otherwise = shows i  


floori :: RealFrac a => a -> Int
floori = floor