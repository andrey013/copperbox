{-# OPTIONS -Wall #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  ZMidi.Construction.OutputMidi
-- Copyright   :  (c) Stephen Tetley 2010
-- License     :  BSD3
--
-- Maintainer  :  stephen.tetley@gmail.com
-- Stability   :  unstable
-- Portability :  GHC
--
-- ...
--
--------------------------------------------------------------------------------

module ZMidi.Construction.OutputMidi
  (
    writeMidiMCT
  ) where

import ZMidi.Construction.Datatypes
import ZMidi.Construction.Utils.HList
import qualified ZMidi.Construction.Utils.JoinList as JL

import ZMidi.Core                               -- package: zmidi-core

import Control.Applicative
import qualified Data.Foldable as F
import Data.List
import Data.Time
import Data.Word





-- Note - this is a Double so it is the right type for calculating
-- durations, in MIDI files the size of the ticks-per-beat 
-- designator is actually a Word16.
--
ticks_per_quarternote :: Double
ticks_per_quarternote = 480

durationr :: Double -> Word32
durationr r = floor $ (4 * ticks_per_quarternote) * r


--------------------------------------------------------------------------------

-- Note - the state tracks absolute time, conversion to delta time 
-- is performed as a traversal afterwards

data RenderState = RenderState
      { rs_volume               :: Word8
      , rs_ellapsed_time        :: Word32
      , rs_channel_number       :: Word8        -- 0..15
      }
  deriving (Eq,Show)

zeroRS :: RenderState
zeroRS = RenderState { rs_volume          = 127
                     , rs_ellapsed_time   = 0
                     , rs_channel_number  = 0
                     }


newtype OutMonad a = OutMonad { 
          getOutMonad :: RenderState -> (a,RenderState) }


instance Functor OutMonad where
  fmap f mf = OutMonad $ \s -> let (a,s1) = getOutMonad mf s in (f a,s1)

instance Applicative OutMonad where
  pure a    = OutMonad $ \s -> (a,s)
  mf <*> ma = OutMonad $ \s -> let (f,s1) = getOutMonad mf s
                                   (a,s2) = getOutMonad ma s1
                               in (f a,s2)

instance Monad OutMonad where
  return a  = OutMonad $ \s -> (a,s)
  m >>= k   = OutMonad $ \s -> let (a,s1) = getOutMonad m s
                               in (getOutMonad . k) a s1
                              

runOutMonad :: OutMonad a -> a
runOutMonad mf = fst $ getOutMonad mf zeroRS


getsRS :: (RenderState -> a) -> OutMonad a
getsRS fn = OutMonad $ \s -> (fn s,s)


setsRS :: (RenderState -> RenderState) -> OutMonad ()
setsRS fn = OutMonad $ \s -> ((),fn s)


incrChannelNumber :: OutMonad ()
incrChannelNumber = 
    setsRS (\s -> let i = rs_channel_number s in s { rs_channel_number = i+1})


incrEllapsedTime :: Word32 -> OutMonad ()
incrEllapsedTime n = 
    setsRS (\s -> let i = rs_ellapsed_time s in s { rs_ellapsed_time = i+n})

zeroEllapsedTime    :: OutMonad ()
zeroEllapsedTime    = setsRS (\s -> s { rs_ellapsed_time = 0 })

getEllapsedTime     :: OutMonad Word32
getEllapsedTime     = getsRS rs_ellapsed_time

getChannelNumber    :: OutMonad Word8
getChannelNumber    = getsRS rs_channel_number



-- Nice to have time stamp ....


writeMidiMCT :: FilePath -> MultiChannelTrack -> IO ()
writeMidiMCT filename mct = 
    getZonedTime >>= \ztim -> writeMidi filename (outputMCT ztim mct)



outputMCT :: ZonedTime -> MultiChannelTrack -> MidiFile
outputMCT ztim mct = 
    MidiFile hdr $ infoTrack ztim : JL.zipWithIntoList fn mct [1..]
  where
    fn  = flip outputTrack
    hdr = Header MF1 len tpb
    len = fromIntegral $ 1 + JL.length mct
    tpb = TPB $ floor ticks_per_quarternote


infoTrack :: ZonedTime -> Track
infoTrack ztim = Track $ 
    [ genericText "Generated by ZMidi."
    , genericText $ midiTimeStamp ztim
    , sequenceName "Track 0"
    , end_of_track
    ]


genericText :: String -> Message
genericText ss = (0, MetaEvent $ TextEvent GENERIC_TEXT ss)

sequenceName :: String -> Message
sequenceName ss = (0, MetaEvent $ TextEvent SEQUENCE_NAME ss)


setTempo :: Double -> Message
setTempo bpm = (0, MetaEvent $ SetTempo mspqn) 
  where
    mspqn = floor $ microseconds_per_minute / bpm

microseconds_per_minute :: Double
microseconds_per_minute = 60000000


-- programChange :: Word8 -> Word8 -> Message
-- programChange inst ch = (0, VoiceEvent $ ProgramChange ch inst)

outputTrack :: Int -> JL.JoinList Section -> Track
outputTrack n xss = Track $ unwind $ fmap (runOutMonad . buildSection) xss
  where 
    unwind hs = toListH $ consH info $ F.foldr appendH emptyH hs 
    info      = sequenceName $ "Track" ++ show n


buildSection  :: Section -> OutMonad (H Message)
buildSection (Section tmpo xss) = fmap (consH (setTempo tmpo)) body 
  where
    chans = limit16 xss
    body  = fmap (deltaTransform . concatMessages) $ JL.toListM voiceData chans


-- The MIDI file format only allows 16 channels per track.
--
limit16 :: JL.JoinList a -> JL.JoinList a
limit16 = JL.take 16

concatMessages :: [[Message]] -> [Message]
concatMessages []     = []
concatMessages [x]    = x
concatMessages (x:xs) = foldl' (mergeOrdered cmp) x xs
  where
    cmp (d1,_) (d2,_) = d1 `compare` d2


mergeOrdered :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
mergeOrdered cmp = step
  where
    step []     ys      = ys
    step xs     []      = xs
    step (x:xs) (y:ys)  = case cmp x y of
                            LT -> x : step xs (y:ys)
                            EQ -> x : y : step xs ys
                            GT -> y : step (x:xs) ys

-- Upto the onset time merge, messages are labelled with absolute 
-- time rather than delta time.
--
-- This transforms them to use delta time.
--
deltaTransform :: [Message] -> H Message
deltaTransform = step 0
  where
    step _    []              = wrapH end_of_track
    step abst ((evt,body):xs) = (evt - abst,body) `consH` step evt xs



end_of_track :: Message
end_of_track = (0, MetaEvent $ EndOfTrack)


type HChannelData = H Message


voiceData :: SectionVoice -> OutMonad [Message]
voiceData (SectionVoice xs) = do 
    hs <- primitives xs 
    incrChannelNumber 
    zeroEllapsedTime
    return $ toListH hs


primitives :: [MidiPrim] -> OutMonad HChannelData
primitives []     = return emptyH
primitives (x:xs) = step x xs
  where
    step a []     = primitive a
    step a (b:bs) = liftA2 appendH (primitive a) (step b bs)

primitive :: MidiPrim -> OutMonad HChannelData
primitive (PNote d props p)   = primNote (durationr d) props p
primitive (PChord d props ps) = primChord (durationr d) props ps
primitive (PRest d)           = incrEllapsedTime (durationr d) >> return emptyH
primitive (PMsg msg)          = either voiceMsg metaEvent msg


primNote :: Word32 -> PrimProps -> Word8 -> OutMonad HChannelData
primNote d props p = do 
    et <- getEllapsedTime
    ch <- getChannelNumber
    incrEllapsedTime d
    let non = mkNoteOn  et     p ch (velocity_on props)
    let nof = mkNoteOff (et+d) p ch (velocity_off props)
    return (twoH non nof)


primChord :: Word32 -> PrimProps -> [Word8] -> OutMonad HChannelData
primChord d props ps  = do 
    et <- getEllapsedTime
    ch <- getChannelNumber
    incrEllapsedTime d
    let nons = map (\p -> mkNoteOn  et     p ch (velocity_on props))  ps
    let nofs = map (\p -> mkNoteOff (et+d) p ch (velocity_off props)) ps
    return (fromListH nons `appendH` fromListH nofs)


voiceMsg :: VoiceMsg -> OutMonad HChannelData
voiceMsg f = do 
    ch <- getChannelNumber
    return $ wrapH $ (0, VoiceEvent $ getVoiceMsg f ch)

metaEvent :: MetaEvent -> OutMonad HChannelData
metaEvent evt = return $ wrapH (0, MetaEvent evt) 

mkNoteOn :: Word32 -> Word8 -> Word8 -> Word8 -> Message
mkNoteOn dt pch ch vel = (dt, VoiceEvent $ NoteOn ch pch vel)

mkNoteOff :: Word32 -> Word8 -> Word8 -> Word8 -> Message
mkNoteOff dt pch ch vel = (dt, VoiceEvent $ NoteOff ch pch vel)



--------------------------------------------------------------------------------


-- | To be used with getZonedTime

midiTimeStamp :: ZonedTime -> String
midiTimeStamp zt = bodyS [] 
  where
    bodyS       = localTimeS . showChar ' ' . localDayS
    local_tim   = zonedTimeToLocalTime zt
    localTimeS  = timeOfDay  $ localTimeOfDay $ local_tim
    localDayS   = showString $ showGregorian  $ localDay local_tim

timeOfDay :: TimeOfDay -> ShowS
timeOfDay t = 
    fn todHour . showChar ':' . fn todMin . showChar ':' . fn (floori . todSec)
  where
    fn f = pad2 (f t) 


pad2 :: Int -> ShowS
pad2 i | i < 10    = ('0':) . shows i
       | otherwise = shows i  


floori :: RealFrac a => a -> Int
floori = floor