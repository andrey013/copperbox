{

{-# LANGUAGE ScopedTypeVariables #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  Mullein.Gen.AbcOutput
-- Copyright   :  (c) Stephen Tetley 2009
-- License     :  BSD-style (as per the Haskell Hierarchical Libraries)
--
-- Maintainer  :  Stephen Tetley <stephen.tetley@gmail.com>
-- Stability   :  highly unstable
-- Portability :  to be determined.
--
-- Pretty print ABC with an attribute grammar
--
--------------------------------------------------------------------------------
}

{
module Mullein.Gen.AbcOutput where

import Mullein.Gen.AbcSyntax
import Mullein.Duration
import Mullein.Pitch
import Mullein.Utils

import Data.Ratio

import Text.PrettyPrint.Leijen 

}

INCLUDE "AbcSyntaxDEFS.ag"

ATTR Part Phrases Phrase Motif [ bgroups : {[Int]} | | ]

ATTR Part Phrase Motif Bar Unison Bracket Element [ | | output : {Doc} ]

ATTR Phrases Bars Unisons Brackets Elements [ | | output USE {:} {[]} :{[Doc]} ]


SEM Part
  | Part        lhs.output    = vsep $ @phrases.output 

SEM Phrase
  | Phrase      lhs.output    = @body.output
  | Repeated    lhs.output    = text "|:" <+> @body.output <+> text ":|"
  | FSRepeat    lhs.output    = text "|:" <+> @body.output 
                                          <+> text "|[1"  <+> @fst_rep.output
                                          <+> text ":|[2" <+> @snd_rep.output
                                          <+> text "|]"



SEM Motif
  | Motif       lhs.output     = doclines @lhs.bgroups 
                                   $ punctuate (text " |") @bars.output

SEM Bar
  | Bar         lhs.output     = @one.output
  | Overlay     lhs.output     = overlay $ @one.output : @orest.output


SEM Unison
  | Unison       lhs.output     = hsep @pulses.output <> 
                                   if @tied then char '-' else empty

SEM Bracket
  | Singleton   lhs.output     = @elt.output
  | Bracket     lhs.output     = hcat $ @elts.output


SEM Element
  | Note        lhs.output    = note @pitch @dmult                
  | Rest        lhs.output    = char 'z' <> multiplier @dmult
  | Spacer      lhs.output    = char 'x' <> multiplier @dmult
  | Chord       lhs.output    = text "Chord - TODO"         
  | GraceNotes  lhs.output    = text "GraceNotes - TODO"

{

data AbcPrefs = AbcPrefs 
      { bars_per_line :: [Int] }
  deriving (Eq,Show)

stdPrefs :: AbcPrefs
stdPrefs = AbcPrefs { bars_per_line = repeat 4 }


-- xs is a list of bars per line  
outputAbc :: AbcPrefs -> Part -> Doc
outputAbc prefs e = output_Syn_Part synthesized 
  where
    synthesized = wrap_Part (sem_Part e) inherited
    inherited   = Inh_Part  { bgroups_Inh_Part = bars_per_line prefs } 




overlay :: [Doc] -> Doc
overlay = vsep . punctuate (text " & ")    

note :: Pitch -> Multiplier -> Doc 
note p m = pitch p <> multiplier m


data PitchChar = UPPER | LOWER
  deriving (Eq,Show)
  
pitch :: Pitch -> Doc
pitch (Pitch l a o) 
    | o > 4     = pitchLabel (PitchLabel l a) LOWER <> octave o 
    | otherwise = pitchLabel (PitchLabel l a) UPPER <> octave o 
  where
    octave :: Int -> Doc
    octave i  | i > 5       = text (replicate (i-5) '\'') 
              | i < 4       = text (replicate (4-i) ',')
              | otherwise   = empty


pitchLabel :: PitchLabel -> PitchChar -> Doc
pitchLabel (PitchLabel l a) pc 
    | pc == LOWER   = accidental a <> (char . toLowerLChar) l
    | otherwise     = accidental a <> (char . toUpperLChar) l
  where     
    accidental :: Accidental -> Doc
    accidental Nat           = empty    
    accidental Sharp         = char '^' 
    accidental Flat          = char '_' 
    accidental DoubleSharp   = text "^^"
    accidental DoubleFlat    = text "__"
    
multiplier :: Duration -> Doc
multiplier dn | dn == 1   = empty
              | otherwise = fn (numerator dn, denominator dn)
  where
    fn (n,1) = integer n
    fn (1,d) = char '/' <> integer d
    fn (n,d) = integer n <> char '/' <> integer d
    

}                
                
          