{

{-# LANGUAGE ScopedTypeVariables #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  Mullein.Gen.LilyPondOutput
-- Copyright   :  (c) Stephen Tetley 2009
-- License     :  BSD-style (as per the Haskell Hierarchical Libraries)
--
-- Maintainer  :  Stephen Tetley <stephen.tetley@gmail.com>
-- Stability   :  highly unstable
-- Portability :  to be determined.
--
-- Pretty print LilyPond with an attribute grammar
--
--------------------------------------------------------------------------------
}

{
module Mullein.Gen.LilyPondOutput where

import Mullein.Gen.LilyPondSyntax
import Mullein.Duration
import Mullein.Pitch
import Mullein.Utils

import Text.PrettyPrint.Leijen 

}

INCLUDE "LilyPondSyntaxDEFS.ag"

ATTR Motif Bar Unison Bracket Element [ | | output : {Doc} ]

ATTR Bars Unisons Brackets Elements [ | | output USE {:} {[]} :{[Doc]} ]

SEM Motif
  | Motif       lhs.output     = hsep $ punctuate (text " |") @bars.output

SEM Bar
  | Bar         lhs.output     = @one.output
  | Overlay     lhs.output     = overlay $ @one.output : @orest.output


SEM Unison
  | Unison      lhs.output     = hsep @pulses.output <> 
                                   if @tied then char '~' else empty

SEM Bracket
  | Singleton   lhs.output     = @elt.output
  | Bracket     lhs.output     = lyBeam @elts.output



SEM Element
  | Note        lhs.output    = note @pitch <> optDuration @opt_drn
  | Rest        lhs.output    = char 'r' <> optDuration @opt_drn 
  | Spacer      lhs.output    = char 's' <> optDuration @opt_drn
  | Chord       lhs.output    = text "Chord - TODO"         
  | GraceNotes  lhs.output    = text "GraceNotes - TODO"
  | Nplet       lhs.output    = text "Nplet - TODO"


{



outputLy :: Motif -> Doc
outputLy e = output_Syn_Motif synthesized 
  where
    synthesized = wrap_Motif (sem_Motif e) inherited
    inherited   = Inh_Motif  { } 


overlay :: [Doc] -> Doc
overlay = dblangles . vsep . punctuate (text " \\")    


note :: Pitch -> Doc 
note (Pitch l a o) = pitchLabel l a <> ove o where
    ove i | i > 0       = text $ replicate i       '\''
          | i < 0       = text $ replicate (abs i) ','
          | otherwise   = empty



-- lilypond middle c is c' 
-- HNotate middle c is c4
rescale :: Pitch -> Pitch
rescale (Pitch l a o)   = Pitch l a (o-3)

pitchLabel :: PitchLetter -> Accidental -> Doc
pitchLabel l a = char (toLowerLChar l) <> accidental a
  where 
    accidental :: Accidental -> Doc
    accidental Nat            = empty
    accidental Sharp          = text "is"
    accidental Flat           = text "es"
    accidental DoubleSharp    = text "isis"
    accidental DoubleFlat     = text "eses"


optDuration :: Maybe Duration -> Doc
optDuration = maybe empty df where
    df 0   = empty
    df drn = let (n,d,dc) = pdElements $ printableDuration drn
             in dots dc $ durn n d

    durn 4 1      = command "longa"
    durn 2 1      = command "breve"
    durn 1 i      = int i
    -- TODO - ideally we shouldn't have 'error' errors here, we should be
    -- using throwError. But that means making a lot of pure code monadic
    -- ... is there another way to do it?
    durn n d      = error $ "lyDuration failed on - " ++ show n ++ "%" ++ show d

    dots :: Int -> (Doc -> Doc)
    dots i | i > 0     = (<> text (replicate i '.'))
           | otherwise = id


lyBeam :: [Doc] -> Doc
lyBeam (x:xs) = x <> char '[' <+> hsep xs <> char ']'
lyBeam []     = empty

command :: String -> Doc
command = (char '\\' <>) . text 


}                
                
          