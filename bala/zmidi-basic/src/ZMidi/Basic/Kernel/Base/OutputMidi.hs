{-# OPTIONS -Wall #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  ZMidi.Basic.Kernel.Base.OutputMidi
-- Copyright   :  (c) Stephen Tetley 2011
-- License     :  BSD3
--
-- Maintainer  :  stephen.tetley@gmail.com
-- Stability   :  unstable
-- Portability :  GHC
--
-- Translate MIDI data with @Double@ onset times to Format 1 MIDI
-- files with delta-time onsets.
--
--------------------------------------------------------------------------------

module ZMidi.Basic.Kernel.Base.OutputMidi
  (

    genFormat1
  , genFormat1_IO

  ) where



import ZMidi.Core                               -- package: zmidi-core

import Control.Applicative
import Data.List ( sort )
import Data.Time
import Data.Word

genFormat1 :: [(Double,MidiEvent)] -> MidiFile
genFormat1 evs = MidiFile { mf_header = midi_header
                          , mf_tracks = [ hdr, eventTrack evs ]}
  where
    hdr = MidiTrack [ sequence_name "Track 0", delta_end_of_track ]

-- | As per 'genFormat1' but adds a timestamp to the info track 
-- (track 0).
--
genFormat1_IO :: [(Double,MidiEvent)] -> IO MidiFile
genFormat1_IO evs =
   (\hdr -> MidiFile { mf_header = midi_header
                     , mf_tracks = [ hdr, eventTrack evs ]} )
    <$> io_infoTrack
   



midi_header :: MidiHeader
midi_header = MidiHeader { hdr_format    = MF1
                         , num_tracks    = 2
                         , time_division = TPB 480
                         }

io_infoTrack :: IO MidiTrack
io_infoTrack = mk <$> getZonedTime
  where
    mk ztim = MidiTrack [ generic_text "Generated by ZMidi."
                        , generic_text $ midiTimeStamp ztim
                        , sequence_name "Track 0"
                        , delta_end_of_track
                        ]



generic_text :: String -> MidiMessage
generic_text ss = (0, MetaEvent $ TextEvent GENERIC_TEXT ss)

sequence_name :: String -> MidiMessage
sequence_name ss = (0, MetaEvent $ TextEvent SEQUENCE_NAME ss)


delta_end_of_track :: MidiMessage
delta_end_of_track = (0, MetaEvent $ EndOfTrack)

set_tempo :: MidiMessage
set_tempo = (0, MetaEvent $ SetTempo 500000)



eventTrack :: [(Double,MidiEvent)] -> MidiTrack
eventTrack evts = MidiTrack $ evt0 : evt1 : deltaTrafo evts
  where
    evt0 = sequence_name "Track 1"
    evt1 = set_tempo

    deltaTrafo = step 0 . sort 
    
    step ot ((t,e):xs) = let ut = durationr t 
                         in (fromIntegral $ ut-ot,e) : step ut xs
    step _  []         = [delta_end_of_track]


-- Note - this is a Double so it is the right type for calculating
-- durations, in MIDI files the size of the ticks-per-beat 
-- designator is actually a Word16.
--
ticks_per_quarternote :: Double
ticks_per_quarternote = 480

durationr :: Double -> Word32
durationr r = floor $ (4 * ticks_per_quarternote) * r



--------------------------------------------------------------------------------


-- | To be used with getZonedTime

midiTimeStamp :: ZonedTime -> String

midiTimeStamp zt = bodyS [] 
  where
    bodyS       = localTimeS . showChar ' ' . localDayS
    local_tim   = zonedTimeToLocalTime zt
    localTimeS  = timeOfDay  $ localTimeOfDay $ local_tim
    localDayS   = showString $ showGregorian  $ localDay local_tim

timeOfDay :: TimeOfDay -> ShowS
timeOfDay t = 
    fn todHour . showChar ':' . fn todMin . showChar ':' . fn (floori . todSec)
  where
    fn f = pad2 (f t) 


pad2 :: Int -> ShowS
pad2 i | i < 10    = ('0':) . shows i
       | otherwise = shows i  


floori :: RealFrac a => a -> Int
floori = floor