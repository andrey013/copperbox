{
-- |
-- Module: HMinCaml.KNormal.KNormalToClosure
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Closure conversion
--
}

{
module HMinCaml.KNormal.KNormalToClosure where

import qualified HMinCaml.Closure.ClosureSyn as C
import HMinCaml.Id
import HMinCaml.KNormal.KNormalSyn
import qualified HMinCaml.M as M
import qualified HMinCaml.S as S
import HMinCaml.Type

}

INCLUDE "KNormal/KNormalSynDEFS.ag"
INCLUDE "TypeDEFS.ag"


ATTR Expr [ | | closure : {C.Expr} ]
ATTR Expr [ | toplevel : {C.Fundefs} |  ]
ATTR Expr [ | known : {S.S Id} | ]
ATTR Expr [ | env : {M.M Id Type} | ]

SEM Expr
  | Unit      lhs.closure     = C.Unit
  | Int       lhs.closure     = C.Int  @val
  | Float     lhs.closure     = C.Float @val
  | Neg       lhs.closure     = C.Neg  @x
  | Add       lhs.closure     = C.Add  @x @y
  | Sub       lhs.closure     = C.Sub  @x @y
  | FNeg      lhs.closure     = C.FNeg @x
  | FAdd      lhs.closure     = C.FAdd @x @y
  | FSub      lhs.closure     = C.FSub @x @y
  | FMul      lhs.closure     = C.FMul @x @y
  | FDiv      lhs.closure     = C.FDiv @x @y
  | IfEq      lhs.closure     = C.IfEq @x @y @texpr.closure @eexpr.closure
  | IfLE      lhs.closure     = C.IfLE @x @y @texpr.closure @eexpr.closure
  | Let       body.env        = M.add2 @tyid.copy @lhs.env
              lhs.closure     = C.Let @tyid.copy 
                                      @sub.closure
                                      @body.closure
  | Var       lhs.closure     = C.Var @ref
  | LetRec    lhs.closure     = error "todo"
  | App       lhs.closure     = if (@ref `S.mem` @lhs.known) 
                                  then C.AppDir (L @ref) @args
                                  else C.AppCls @ref @args
  | Tuple     lhs.closure     = C.Tuple @refs
  | LetTuple  body.env        = M.addList @tyids.copy @lhs.env
              lhs.closure     = C.LetTuple @tyids.copy @ref @body.closure
  | Get       lhs.closure     = C.Get @aref @iref
  | Put       lhs.closure     = C.Put @aref @iref @vref
  | ExtArray  lhs.closure     = C.ExtArray (L @ref)
  | ExtFunApp lhs.closure     = C.AppDir (L $ "min_caml_" ++ @nref) @args
  
    

{

closure :: Expr -> C.Prog
closure expr = 
    C.Prog (reverse $ toplevel_Syn_Expr synthesized) (closure_Syn_Expr synthesized)
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited   = Inh_Expr { toplevel_Inh_Expr  = [], 
                             env_Inh_Expr       = M.empty,
                             known_Inh_Expr     = S.empty }
    

}       