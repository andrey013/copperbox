{
-- |
-- Module: HMinCaml.KNormal.KNormal
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- K Normal form datatypes
--
}

{
module HMinCaml.KNormal.KNormal where


import HMinCaml.Id
import HMinCaml.KNormal.KNormalSyn
import qualified HMinCaml.M as M
import qualified HMinCaml.S as S
import HMinCaml.Type

}

INCLUDE "KNormal/KNormalSynDEFS.ag"
INCLUDE "TypeDEFS.ag"


ATTR Expr [ | | freeVars : { S.S Id } ]

SEM Expr
  | Unit Int Float
                lhs.freeVars  = S.empty
                
  | Neg FNeg                
                lhs.freeVars  = S.singleton @x
                
  | Add Sub FAdd FSub FMul FDiv
                lhs.freeVars  = S.ofList [@x,@y]
  | IfEq IfLE
                lhs.freeVars  = @x `S.add` (@y `S.add` 
                                  (@texpr.freeVars `S.union` @eexpr.freeVars)) 

  | Let         lhs.freeVars  = S.union @sub.freeVars 
                                        (S.remove @tyid.freeVars @body.freeVars)
                 
  | Var         lhs.freeVars  = S.singleton @ref
  
  | LetRec      lhs.freeVars  = S.diff (@fundef.freeVars `S.union` @body.freeVars) 
                                       (S.singleton @fundef.varid)
  
  | App         lhs.freeVars  = S.ofList (@ref : @args)

  | Tuple       lhs.freeVars  = S.ofList @refs 

  | LetTuple    lhs.freeVars  = @ref `S.add` (@body.freeVars `S.diff`  
                                                        @tyids.freeVars)
                                                          
  | Get         lhs.freeVars  = S.ofList [@aref,@iref] 

  | Put         lhs.freeVars  = S.ofList [@aref,@iref,@vref]
                                     
  | ExtArray    lhs.freeVars  = S.empty
  
  | ExtFunApp   lhs.freeVars  = S.ofList @args
  
ATTR Fundef [ | | freeVars  : { S.S Id } ]
ATTR Fundef [ | | varid  : {Id} ]

SEM Fundef
  | Fundef      lhs.freeVars  = @body.freeVars `S.diff` @args.freeVars  

SEM Fundef 
  | Fundef      lhs.varid     = @name.freeVars

ATTR TypeIds [ | | freeVars USE {`S.add`} {S.empty} : { S.S Id } ]

ATTR TypeId [ | | freeVars : { Id } ]

SEM TypeId
  | Tuple       lhs.freeVars  = @argId


 
  
{

freeVars :: Expr -> S.S Id
freeVars expr = freeVars_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited = Inh_Expr {  }
 
} 