{
-- |
-- Module: HMinCaml.Elim
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Eliminate unnecessary definitions
--
}

{
module HMinCaml.KNormal.Elim where

import HMinCaml.Id
import HMinCaml.KNormal.KNormalSyn
import qualified HMinCaml.S as S
import HMinCaml.Type

import Data.List ( find )
}

INCLUDE "KNormal/KNormalSynDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Expr [ | | elim : {Expr} ]

SEM Expr 
  | *   lhs.elim = undefined

{-

f :: Expr -> Expr         
f (IfEq x y e1 e2)    = IfEq x y (f e1) (f e2)
f (IfLE x y e1 e2)    = IfLE x y (f e1) (f e2)
f (Let (x,t) e1 e2)   = let e1' = f e1; e2' = f e2 in
    if effect e1' || S.mem x (freeVars e2') then Let (x,t) e1' e2' else e2'
    
f (LetRec (Fundef (x,t) yts e1) e2) = let e2' = f e2 in
    if S.mem x (freeVars e2') then LetRec (Fundef (x,t) yts (f e1)) e2' else e2'

f (LetTuple xts y e)  = let xs    = map fst xts
                            e'    = f e 
                            live  = freeVars e' 
                        in maybe e' (const $ LetTuple xts y e')
                                    (find (\x -> S.mem x live) xs)
                                                                    
f e                    = e

-}

{

effect :: Expr -> Bool
effect (Let _ e1 e2)      = effect e1 || effect e2
effect (IfEq _ _ e1 e2)   = effect e1 || effect e2
effect (IfLE _ _ e1 e2)   = effect e1 || effect e2
effect (LetRec _ e)       = effect e 
effect (LetTuple _ _ e)   = effect e
effect (App _ _)          = True
effect (Put _ _ _)        = True
effect (ExtFunApp _ _)    = True
effect _                  = False


elim :: Expr -> Expr
elim expr = elim_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited = Inh_Expr { }

}