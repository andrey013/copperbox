{
-- |
-- Module: HMinCaml.ConstFold
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Constant folding
--
}

{
module HMinCaml.ConstFold where

import HMinCaml.CompilerMonad
import HMinCaml.Id
import HMinCaml.KNormal
import qualified HMinCaml.M as M
import HMinCaml.Type
import HMinCaml.Utils

type Env = M.M Id Expr

findInt :: Id -> Env -> Maybe Int
findInt s env = case M.find s env of
    Just (Int i) -> Just i
    _            -> Nothing

findFloat :: Id -> Env -> Maybe Float
findFloat s env = case M.find s env of
    Just (Float d) -> Just d
    _              -> Nothing

findTuple :: Id -> Env -> Maybe [Id]                 
findTuple x env = case M.find x env of
    Just (Tuple ys) -> Just ys
    _               -> Nothing
    


both :: Maybe a -> Maybe b -> Maybe (a,b)
both (Just a) (Just b) = Just (a,b) 
both _        _        = Nothing
      
alt :: Maybe a -> Maybe b -> Maybe (Either a b)
alt (Just a) _        = Just (Left a)
alt _        (Just b) = Just (Right b)
alt _        _        = Nothing


}

INCLUDE "KNormalDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Expr Fundef [ | | copy : SELF ]

ATTR Expr   [ | | constFold : {Expr} ]

ATTR Fundef   [ | | constFold : {Fundef} ]

ATTR Expr Fundef  [ | env : {Env} | ]



SEM Expr 
  | Var   lhs.constFold   = maybe @copy Int (findInt @ref @lhs.env)
  | Neg   lhs.constFold   = maybe @copy (Int . negate) (findInt @ref @lhs.env)
  | Add   lhs.constFold   = maybe @copy 
                                  (Int . uncurry (+)) 
                                  (both (findInt @ref1 @lhs.env) 
                                        (findInt @ref2 @lhs.env))
  | Sub   lhs.constFold   = maybe @copy 
                                  (Int . uncurry (-)) 
                                  (both (findInt @ref1 @lhs.env) 
                                        (findInt @ref2 @lhs.env))
  | FNeg  lhs.constFold   = maybe @copy (Float . negate) (findFloat @ref @lhs.env)
  | FAdd  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (+)) 
                                  (both (findFloat @ref1 @lhs.env) 
                                        (findFloat @ref2 @lhs.env))
  | FSub  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (-)) 
                                  (both (findFloat @ref1 @lhs.env) 
                                        (findFloat @ref2 @lhs.env)) 
  | FMul  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (*)) 
                                  (both (findFloat @ref1 @lhs.env) 
                                        (findFloat @ref2 @lhs.env))  
  | FDiv  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (/)) 
                                  (both (findFloat @ref1 @lhs.env) 
                                        (findFloat @ref2 @lhs.env))
  | IfEq  
          loc.texpr'      = @texpr.constFold
          loc.eexpr'      = @eexpr.constFold
          lhs.constFold   = maybe (IfEq @ref1 @ref2 @loc.texpr' @loc.eexpr')
                                  (\a -> if epeq a then @loc.texpr' 
                                                   else @loc.eexpr') 
                                  (alt (both (findInt   @ref1 @lhs.env) 
                                             (findInt   @ref2 @lhs.env))
                                       (both (findFloat @ref1 @lhs.env) 
                                             (findFloat @ref2 @lhs.env)))                                               
  | IfLE                
          loc.texpr'      = @texpr.constFold
          loc.eexpr'      = @eexpr.constFold
          lhs.constFold   = maybe (IfLE @ref1 @ref2 @loc.texpr' @loc.eexpr')
                                  (\a -> if epLeq a then @loc.texpr' 
                                                    else @loc.eexpr') 
                                  (alt (both (findInt   @ref1 @lhs.env) 
                                             (findInt   @ref2 @lhs.env))
                                       (both (findFloat @ref1 @lhs.env) 
                                             (findFloat @ref2 @lhs.env)))                                                                      
  | Let   loc.sub'        = @sub.constFold
          body.env        = M.add @tyid.argId @loc.sub' @lhs.env
          loc.body'       = @body.constFold
          lhs.constFold   = Let @tyid.copy @loc.sub' @loc.body'
  | LetRec  
          lhs.constFold   = LetRec @fundef.constFold @body.constFold          
  
  | LetTuple
          lhs.constFold   = maybe (LetTuple @tyids.copy @ref @body.constFold)
                                  (\xs -> foldleft2 (\e xt f -> f xt e) 
                                                    @body.constFold
                                                    xs 
                                                    @tyids.constFoldF)
                                  (findTuple @ref @lhs.env)
  | Unit Int Float App Tuple Get Put ExtArray ExtFunApp    
                lhs.constFold   = @copy


-- For TypeIds return a function to constFold with...

ATTR TypeIds TypeId [ env : {Env} | | ]

ATTR TypeIds [ | | constFoldF USE {:} {[]} : {[(Id -> Expr -> Expr)]} ]

ATTR TypeId [ | | constFoldF : {(Id -> Expr -> Expr)} ]

SEM TypeId
  | Tuple   lhs.constFoldF   = (\x e -> Let @copy (Var x) e)
    



SEM Fundef
  | Fundef
          lhs.constFold   = Fundef @name.copy @args.copy @body.constFold      



  
{

-- either-pair-equal
epeq :: (Eq a, Eq b) => Either (a,a) (b,b) -> Bool
epeq (Left  (a,b)) = a==b
epeq (Right (a,b)) = a==b

-- either-pair-less-than-or-equal
epLeq :: (Ord a, Ord b) => Either (a,a) (b,b) -> Bool
epLeq (Left  (a,b)) = a<=b
epLeq (Right (a,b)) = a<=b

}

{-

g :: Env -> Expr -> Expr
g env (Var x) | memi x env      = Int (findi x env)           
g env (Neg x) | memi x env      = Int (negate (findi x env))
g env (Add x y) 
    | memi x env && memi y env  = Int (findi x env + findi y env)
g env (Sub x y) 
    | memi x env && memi y env  = Int (findi x env - findi y env)
g env (FNeg x) 
    | memf x env                = Float (negate (findf x env))
g env (FAdd x y) 
    | memf x env && memf y env  = Float (findf x env + findf y env)
g env (FSub x y)
    | memf x env && memf y env  = Float (findf x env - findf y env)
g env (FMul x y) 
    | memf x env && memf y env  = Float (findf x env * findf y env)
g env (FDiv x y) 
    | memf x env && memf y env  = Float (findf x env / findf y env)
g env (IfEq x y e1 e2) 
    | memi x env && memi y env  = if findi x env == findi y env 
                                    then g env e1 
                                    else g env e2
                                    
g env (IfEq x y e1 e2) 
    | memf x env && memf y env  = if findf x env == findf y env 
                                    then g env e1 
                                    else g env e2
                                    
g env (IfEq x y e1 e2)          = IfEq x y (g env e1) (g env e2)
g env (IfLE x y e1 e2) 
    | memi x env && memi y env  = if findi x env <= findi y env 
                                    then g env e1 
                                    else g env e2
                                    
g env (IfLE x y e1 e2)
    | memf x env && memf y env  = if findf x env <= findf y env 
                                    then g env e1 
                                    else g env e2
                                    
g env (IfLE x y e1 e2)          = IfLE x y (g env e1) (g env e2)
g env (Let (x,t) e1 e2)         = let e1' = g env e1
                                      e2' = g (M.add x e1' env) e2 
                                  in Let (x,t) e1' e2'
                                  
g env (LetRec (Fundef x ys e1) e2)  = LetRec (Fundef x ys (g env e1)) (g env e2)
g env (LetTuple xts y e) 
    | memt y env                = foldleft2 (\e' xt z -> Let xt (Var z) e')
                                            (g env e)
                                            xts
                                            (findt y env)
    | otherwise                 = LetTuple xts y (g env e)
  
g _   e                         = e

-}

{
                
constFold :: Expr -> CM Expr
constFold = undefined -- return . g M.empty

}

