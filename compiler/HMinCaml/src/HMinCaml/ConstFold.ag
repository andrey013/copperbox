{
-- |
-- Module: HMinCaml.ConstFold
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Constant folding
--
}

{
module HMinCaml.ConstFold where


import HMinCaml.Id
import HMinCaml.KNormalSyn
import qualified HMinCaml.M as M
import HMinCaml.Type
import HMinCaml.Utils

type Env = M.M Id Expr

findInt :: Id -> Env -> Maybe Int
findInt s env = case M.find s env of
    Just (Int i) -> Just i
    _            -> Nothing

findFloat :: Id -> Env -> Maybe Float
findFloat s env = case M.find s env of
    Just (Float d) -> Just d
    _              -> Nothing

findTuple :: Id -> Env -> Maybe [Id]                 
findTuple x env = case M.find x env of
    Just (Tuple ys) -> Just ys
    _               -> Nothing
    


both :: Maybe a -> Maybe b -> Maybe (a,b)
both (Just a) (Just b) = Just (a,b) 
both _        _        = Nothing
      
alt :: Maybe a -> Maybe b -> Maybe (Either a b)
alt (Just a) _        = Just (Left a)
alt _        (Just b) = Just (Right b)
alt _        _        = Nothing


}

INCLUDE "KNormalDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Expr Fundef [ | | copy : SELF ]

ATTR Expr   [ | | constFold : {Expr} ]

ATTR Fundef   [ | | constFold : {Fundef} ]

ATTR Expr Fundef  [ | env : {Env} | ]



SEM Expr 
  | Var   lhs.constFold   = maybe @copy Int (findInt @ref @lhs.env)
  | Neg   lhs.constFold   = maybe @copy (Int . negate) (findInt @x @lhs.env)
  | Add   lhs.constFold   = maybe @copy 
                                  (Int . uncurry (+)) 
                                  (both (findInt @x @lhs.env) 
                                        (findInt @y @lhs.env))
  | Sub   lhs.constFold   = maybe @copy 
                                  (Int . uncurry (-)) 
                                  (both (findInt @x @lhs.env) 
                                        (findInt @y @lhs.env))
  | FNeg  lhs.constFold   = maybe @copy (Float . negate) (findFloat @x @lhs.env)
  | FAdd  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (+)) 
                                  (both (findFloat @x @lhs.env) 
                                        (findFloat @y @lhs.env))
  | FSub  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (-)) 
                                  (both (findFloat @x @lhs.env) 
                                        (findFloat @y @lhs.env)) 
  | FMul  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (*)) 
                                  (both (findFloat @x @lhs.env) 
                                        (findFloat @y @lhs.env))  
  | FDiv  lhs.constFold   = maybe @copy 
                                  (Float . uncurry (/)) 
                                  (both (findFloat @x @lhs.env) 
                                        (findFloat @y @lhs.env))
  | IfEq  
          loc.texpr'      = @texpr.constFold
          loc.eexpr'      = @eexpr.constFold
          lhs.constFold   = maybe (IfEq @x @y @loc.texpr' @loc.eexpr')
                                  (\a -> if epeq a then @loc.texpr' 
                                                   else @loc.eexpr') 
                                  (alt (both (findInt   @x @lhs.env) 
                                             (findInt   @y @lhs.env))
                                       (both (findFloat @x @lhs.env) 
                                             (findFloat @y @lhs.env)))                                               
  | IfLE                
          loc.texpr'      = @texpr.constFold
          loc.eexpr'      = @eexpr.constFold
          lhs.constFold   = maybe (IfLE @x @y @loc.texpr' @loc.eexpr')
                                  (\a -> if epLeq a then @loc.texpr' 
                                                    else @loc.eexpr') 
                                  (alt (both (findInt   @x @lhs.env) 
                                             (findInt   @y @lhs.env))
                                       (both (findFloat @x @lhs.env) 
                                             (findFloat @y @lhs.env)))                                                                      
  | Let   loc.sub'        = @sub.constFold
          body.env        = M.add @tyid.argId @loc.sub' @lhs.env
          loc.body'       = @body.constFold
          lhs.constFold   = Let @tyid.copy @loc.sub' @loc.body'
  | LetRec  
          lhs.constFold   = LetRec @fundef.constFold @body.constFold          
  
  | LetTuple
          lhs.constFold   = maybe (LetTuple @tyids.copy @ref @body.constFold)
                                  (\xs -> foldleft2 (\e xt f -> f xt e) 
                                                    @body.constFold
                                                    xs 
                                                    @tyids.constFoldF)
                                  (findTuple @ref @lhs.env)
  | Unit Int Float App Tuple Get Put ExtArray ExtFunApp    
                lhs.constFold   = @copy


-- For TypeIds return a function to constFold with...

ATTR TypeIds TypeId [ env : {Env} | | ]

ATTR TypeIds [ | | constFoldF USE {:} {[]} : {[(Id -> Expr -> Expr)]} ]

ATTR TypeId [ | | constFoldF : {(Id -> Expr -> Expr)} ]

SEM TypeId
  | Tuple   lhs.constFoldF   = (\x e -> Let @copy (Var x) e)
    



SEM Fundef
  | Fundef
          lhs.constFold   = Fundef @name.copy @args.copy @body.constFold      



  
{

-- either-pair-equal
epeq :: (Eq a, Eq b) => Either (a,a) (b,b) -> Bool
epeq (Left  (a,b)) = a==b
epeq (Right (a,b)) = a==b

-- either-pair-less-than-or-equal
epLeq :: (Ord a, Ord b) => Either (a,a) (b,b) -> Bool
epLeq (Left  (a,b)) = a<=b
epLeq (Right (a,b)) = a<=b


                
constFold :: Expr -> Expr
constFold expr = constFold_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited = Inh_Expr { env_Inh_Expr = M.empty }

}

