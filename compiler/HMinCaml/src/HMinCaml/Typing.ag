{
-- |
-- Module: HMinCaml.Typing
-- License: as per original MinCaml
-- Copyright 2009 Stephen Tetley
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Type inference
--
}

{

module HMinCaml.Typing  where

import HMinCaml.Id
import HMinCaml.M
import HMinCaml.Syntax
import HMinCaml.Type
import HMinCaml.Unification

import qualified Data.Map as Map
import Data.Monoid

}

INCLUDE "SyntaxDEFS.ag"
INCLUDE "TypeDEFS.ag"

{


unboundErr :: String -> Type
unboundErr = TError . ("unbound variable " ++) 

newVar :: Int -> Type
newVar = TVar                                                        

isErr :: Type -> Bool
isErr (TError _)     = True
isErr _              = False  


}

ATTR Expr Fundef [ | env : {TypeEnv} | ]
ATTR Expr Fundef [ | uniq : {Int} | ]  


ATTR Expr Fundef [ | | infer : {(Subst,Type)} ]

SEM Expr 
  | Unit        lhs.infer     = (mempty,TUnit)
  
  | Bool        lhs.infer     = (mempty,TBool)
  
  | Int         lhs.infer     = (mempty,TInt)
  
  | Float       lhs.infer     = (mempty,TFloat)
  
  | Not         loc.(s1,t1)   = @expr.infer
                lhs.infer     = if @loc.t1 == inttype 
                                  then (@loc.s1, inttype)
                                  else (mempty, TError $ "Not " ++ show @loc.t1)
                                  
  | Neg         loc.(s1,t1)   = @expr.infer
                lhs.infer     = if @loc.t1 == inttype 
                                  then (@loc.s1, inttype)
                                  else (mempty, TError $ "Neg " ++ show @loc.t1)

  
  | Add         loc.(s1,t1)   = @expr1.infer
                loc.(s2,t2)   = @expr2.infer
                lhs.infer     = if arrow2 @loc.t1 @loc.t2 inttype == int2int2int 
                                  then (@loc.s1 `mappend` @loc.s2, inttype)
                                  else (mempty, TError $ "Neg " ++ show @loc.t1)

{-
  | Sub         expr1   : Expr  
                expr2   : Expr
  | FNeg        expr    : Expr
  | FAdd        expr1   : Expr  
                expr2   : Expr
  | FSub        expr1   : Expr  
                expr2   : Expr
  | FMul        expr1   : Expr  
                expr2   : Expr
  | FDiv        expr1   : Expr  
                expr2   : Expr
  | Eq          expr1   : Expr  
                expr2   : Expr
  | LE          expr1   : Expr  
                expr2   : Expr
  | If          econd   : Expr  
                ethen   : Expr  
                eelse   : Expr
  | Let         varName : TypeId
                sub     : Expr  
                body    : Expr
-}
                
  | Var         loc.(t,n')    = case @var `element` @lhs.env of
                                  Nothing -> (unboundErr @var, @lhs.uniq)
                                  Just s  -> instantiate s @lhs.uniq                
                lhs.infer     = (mempty,@loc.t)
                lhs.uniq      = @lhs.uniq + @loc.n'


{-
  | LetRec      funDef  : Fundef    
                body    : Expr
  | App         expr    : Expr
                args    : Exprs
  | Tuple       elts    : Exprs
  | LetTuple    idents  : TypeIds  
                sub     : Expr  
                body    : Expr
  | Array       expr1   : Expr  
                expr2   : Expr
  | Get         aexpr   : Expr  
                iexpr   : Expr
  | Put         aexpr   : Expr  
                ixexpr  : Expr  
                vexpr   : Expr
                
-}                
SEM Fundef
  | Fundef      lhs.infer     = @body.infer   
    
{

infer :: Expr -> Type
infer e = snd $ infer_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr e) inherited
    inherited   = Inh_Expr  { env_Inh_Expr   = initial_type_env,
                              uniq_Inh_Expr = 0 }

typing :: Expr -> Expr
typing e = case infer e of
              TUnit -> e
              _     -> error $ "Type inference failed " ++ show e       

}

    