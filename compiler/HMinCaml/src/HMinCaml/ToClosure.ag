{
-- |
-- Module: HMinCaml.Closure
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Closure conversion
--
}

{
module HMinCaml.ToClosure where

import qualified HMinCaml.ClosureSyn as C
import HMinCaml.Id
import HMinCaml.KNormalSyn
import qualified HMinCaml.M as M
import qualified HMinCaml.S as S
import HMinCaml.Type

}

INCLUDE "KNormalDEFS.ag"
INCLUDE "TypeDEFS.ag"


ATTR Expr [ | | closure : {C.Expr} ]
ATTR Expr [ | toplevel : {C.Fundefs} |  ]
ATTR Expr [ | known : {S.S Id} | ]
ATTR Expr [ | env : {M.M Id Type} | ]

SEM Expr
  | Unit      lhs.closure     = C.Unit
  | Int       lhs.closure     = C.Int  @val
  | Float     lhs.closure     = C.Float @val
  | Neg       lhs.closure     = C.Neg  @x
  | Add       lhs.closure     = C.Add  @x @y
  | Sub       lhs.closure     = C.Sub  @x @y
  | FNeg      lhs.closure     = C.FNeg @x
  | FAdd      lhs.closure     = C.FAdd @x @y
  | FSub      lhs.closure     = C.FSub @x @y
  | FMul      lhs.closure     = C.FMul @x @y
  | FDiv      lhs.closure     = C.FDiv @x @y
  | IfEq      lhs.closure     = C.IfEq @x @y @texpr.closure @eexpr.closure
  | IfLE      lhs.closure     = C.IfLE @x @y @texpr.closure @eexpr.closure
  | Let       body.env        = M.add2 @tyid.copy @lhs.env
              lhs.closure     = C.Let @tyid.copy 
                                      @sub.closure
                                      @body.closure
  | Var       lhs.closure     = C.Var @ref
  | LetRec    lhs.closure     = error "todo"
  | App       lhs.closure     = if (@ref `S.mem` @lhs.known) 
                                  then C.AppDir (L @ref) @args
                                  else C.AppCls @ref @args
  | Tuple     lhs.closure     = C.Tuple @refs
  | LetTuple  body.env        = M.addList @tyids.copy @lhs.env
              lhs.closure     = C.LetTuple @tyids.copy @ref @body.closure
  | Get       lhs.closure     = C.Get @aref @iref
  | Put       lhs.closure     = C.Put @aref @iref @vref
  | ExtArray  lhs.closure     = C.ExtArray (L @ref)
  | ExtFunApp lhs.closure     = C.AppDir (L $ "min_caml_" ++ @nref) @args
  
    
{-


g :: M.M Id Type -> S.S Id -> K.Expr -> C.Expr
g env known a = step a where
    step K.Unit               = Unit
    step (K.Int i)            = Int i
    step (K.Float d)          = Float d
    step (K.Neg x)            = Neg x
    step (K.Add x y)          = Add x y
    step (K.Sub x y)          = Sub x y
    step (K.FNeg x)           = FNeg x
    step (K.FAdd x y)         = FAdd x y
    step (K.FSub x y)         = FSub x y
    step (K.FMul x y)         = FMul x y
    step (K.FDiv x y)         = FDiv x y
    step (K.IfEq x y e1 e2)   = IfEq x y (g env known e1) (g env known e2)
    step (K.IfLE x y e1 e2)   = IfLE x y (g env known e1) (g env known e2)
    step (K.Let (x,t) e1 e2)  = Let (x,t) (g env known e1) 
                                          (g (M.add x t env) known e2)
    step (K.Var x)            = Var x
   
    step (K.LetRec _ _)       = error "todo"

    step (K.App x ys) 
        |  S.mem x known      = AppDir (L x) ys
        | otherwise           = AppCls x ys
    step (K.Tuple xs)         = Tuple xs
    step (K.LetTuple xts y e) = LetTuple xts  y (g (M.addList xts env) known e)
    step (K.Get x y)          = Get x y
    step (K.Put x y z)        = Put x y z
    step (K.ExtArray x)       = ExtArray (L x)
    step (K.ExtFunApp x ys)   = AppDir (L $ "min_caml_" ++ x) ys
-}

{

closure :: Expr -> C.Prog
closure expr = 
    C.Prog (reverse $ toplevel_Syn_Expr synthesized) (closure_Syn_Expr synthesized)
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited   = Inh_Expr { toplevel_Inh_Expr  = [], 
                             env_Inh_Expr       = M.empty,
                             known_Inh_Expr     = S.empty }
    

}       