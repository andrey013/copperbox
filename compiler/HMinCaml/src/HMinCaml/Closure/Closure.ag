{
-- |
-- Module: HMinCaml.Closure.Closure
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Closure conversion
--
}

{
module HMinCaml.Closure.Closure where

import HMinCaml.Closure.ClosureSyn
import HMinCaml.Id
import qualified HMinCaml.KNormalSyn as K
import qualified HMinCaml.M as M
import qualified HMinCaml.S as S
import HMinCaml.Type

}

INCLUDE "Closure/ClosureSynDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Expr [ | | fv : {S.S Id} ]

ATTR Closure [ | | fv : {S.S Id} ]


SEM Expr
  | Unit      lhs.fv          = S.empty
  | Int       lhs.fv          = S.empty
  | Float     lhs.fv          = S.empty
  | ExtArray  lhs.fv          = S.empty
  | Neg       lhs.fv          = S.singleton @x
  | FNeg      lhs.fv          = S.singleton @x
  | Add       lhs.fv          = S.ofList [@x, @y]
  | Sub       lhs.fv          = S.ofList [@x, @y]
  | FAdd      lhs.fv          = S.ofList [@x, @y]
  | FSub      lhs.fv          = S.ofList [@x, @y]
  | FMul      lhs.fv          = S.ofList [@x, @y]
  | FDiv      lhs.fv          = S.ofList [@x, @y]
  | Get       lhs.fv          = S.ofList [@aref, @iref]
  | IfEq      lhs.fv          = S.add @x (S.add @y (S.union @texpr.fv @eexpr.fv))
  | IfLE      lhs.fv          = S.add @x (S.add @y (S.union @texpr.fv @eexpr.fv))
  | Let       lhs.fv          = S.union @sub.fv (S.remove @tyid.argId @body.fv)
  | Var       lhs.fv          = S.singleton @x
  | MakeCls   lhs.fv          = S.remove @tyid.argId 
                                         (S.union @close.fv @body.fv)
  | AppCls    lhs.fv          = S.ofList (@ref : @args)
  | AppDir    lhs.fv          = S.ofList @args 
  | Tuple     lhs.fv          = S.ofList @refs
  | LetTuple  lhs.fv          = S.add @ref (S.diff @body.fv 
                                                   (S.ofList @tyids.argId))
  | Put       lhs.fv          = S.ofList [@aref, @iref, @vref]

SEM Closure
  | Closure   lhs.fv          = S.ofList @actual_fv



{

freeVars :: Expr -> S.S Id
freeVars expr = fv_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited = Inh_Expr { }
    

}      