{
-- |
-- Module: HMinCaml.Beta
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- Beta reduction
--
}

{
module HMinCaml.Beta where

import HMinCaml.Id
import HMinCaml.KNormal ( Expr(..), Fundef(..) )
import qualified HMinCaml.M as M
import HMinCaml.Type
import HMinCaml.Utils ( (&?), (&+) )



type Env = M.M Id Id


}

INCLUDE "KNormalDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Expr [ | | beta : {Expr} ]
ATTR Fundef [ | | beta : {Fundef} ]

ATTR Expr Fundef [ | env : {Env} | ]


SEM Expr
  | Unit        lhs.beta      = Unit
  | Int         lhs.beta      = Int @val
  | Float       lhs.beta      = Float @val
  | Neg         lhs.beta      = Neg (@ref &? @lhs.env)
  | Add         lhs.beta      = Add (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | Sub         lhs.beta      = Sub (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | FNeg        lhs.beta      = FNeg (@ref  &? @lhs.env)
  | FAdd        lhs.beta      = FAdd (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | FSub        lhs.beta      = FSub (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | FMul        lhs.beta      = FMul (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | FDiv        lhs.beta      = FDiv (@ref1 &? @lhs.env) (@ref2 &? @lhs.env)
  | IfEq        lhs.beta      = IfEq (@ref1 &? @lhs.env)
                                     (@ref2 &? @lhs.env)
                                     @texpr.beta          
                                     @eexpr.beta
  | IfLE        lhs.beta      = IfLE (@ref1 &? @lhs.env) 
                                     (@ref2 &? @lhs.env)
                                     @texpr.beta          
                                     @eexpr.beta                                     
  | Let         loc.subbeta   = @body.beta
                lhs.env       = case @loc.subbeta of
                                  Var y -> M.add @tyid.argId y @lhs.env
                                  _     -> @lhs.env
                lhs.beta      = case @loc.subbeta of
                                  Var y -> @body.beta                                  
                                  e1'   -> Let @tyid.copy e1' @body.beta
  | Var         lhs.beta      = Var (@ref &? @lhs.env)                                    
  | LetRec      lhs.beta      = LetRec @fundef.beta @body.beta
  | App         lhs.beta      = App (@ref &? @lhs.env) 
                                    (map (&? @lhs.env) @args)                
  | Tuple       lhs.beta      = Tuple (map (&? @lhs.env) @refs)
  | LetTuple    lhs.beta      = LetTuple @tyids.copy
                                         (@ref &? @lhs.env)
                                         @body.beta
  | Get         lhs.beta      = Get (@aref &? @lhs.env) (@iref &? @lhs.env) 
  | Put         lhs.beta      = Put (@aref &? @lhs.env) 
                                    (@iref &? @lhs.env) 
                                    (@vref &? @lhs.env)
  | ExtArray    lhs.beta      = ExtArray @ref
  | ExtFunApp   lhs.beta      = ExtFunApp @nref (map (&? @lhs.env) @args)

SEM Fundef
  | Fundef      lhs.beta      = Fundef @name.copy @args.copy @body.beta  
  
{


beta :: Expr -> Expr
beta expr = beta_Syn_Expr synthesized
  where
    synthesized = wrap_Expr (sem_Expr expr) inherited
    inherited = Inh_Expr { env_Inh_Expr = M.empty }
    
    
}