{
-- |
-- Module: HMinCaml.Simm13
-- License: as per original MinCaml
--
-- Maintainer: Stephen Tetley <stephen.tetley@gmail.com>
-- Stability: unstable
-- Portability: ghc
--
-- 13-bit immediate optimisation
--
}

{
module HMinCaml.Simm13 where


import HMinCaml.Id
import qualified HMinCaml.M as M
import HMinCaml.SparcAsmSyn
import HMinCaml.Type

import Data.Bits

}

{

type Env = M.M Id Int

vfind :: Id_or_Imm -> Env -> Maybe Int
vfind (V i) env = M.find i env
vfind _     _   = Nothing

idsfind :: Id -> Id_or_Imm -> Env -> Maybe (Id,Int)
idsfind x (V y) env = maybe Nothing 
                            (either (\i -> Just (x,i)) (\i -> Just (y,i)))
                            (alt (M.find y env) (M.find x env)) 
idsfind _ _    _    = Nothing



alt :: Maybe a -> Maybe b -> Maybe (Either a b)
alt (Just a) _        = Just (Left a)
alt _        (Just b) = Just (Right b)
alt _        _        = Nothing



}

INCLUDE "SparcAsmDEFS.ag"
INCLUDE "TypeDEFS.ag"

ATTR Prog   [ | | simm13 : {Prog} ]
ATTR SparcT [ | | simm13 : {SparcT} ]
ATTR Expr   [ | | simm13 : {Expr} ]

ATTR Fundefs   [ | | simm13 USE {:} {[]} : {[Fundef]} ]
ATTR Fundef    [ | | simm13 : {Fundef} ]


ATTR Prog SparcT Expr Fundefs Fundef [ | env : {M.M Id Int} | ] 

SEM Prog 
  | Prog      lhs.simm13    = Prog @floats.copy @fundefs.simm13 @instr.simm13

SEM SparcT
  | Ans       lhs.simm13    = Ans @expr.simm13
  
  | Let       lhs.simm13    = undefined
  
  | Forget    lhs.simm13    = Forget @ident @body.simm13
  
SEM Expr
  | Add       lhs.simm13    = maybe @copy 
                                    (\(x,y) -> Add x (C y)) 
                                    (idsfind @lbl @vlbl.copy @lhs.env)                                    
  
  | Sub       lhs.simm13    = maybe @copy 
                                    (\i -> Sub @lbl (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
  
  | SLL       lhs.simm13    = maybe @copy 
                                    (\i -> SLL @lbl (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
  
  | Ld        lhs.simm13    = maybe @copy 
                                    (\i -> Ld @lbl (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
  
  | St        lhs.simm13    = maybe @copy 
                                    (\i -> St @lbl1 @lbl2 (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
  
  | LdDF      lhs.simm13    = maybe @copy 
                                    (\i -> LdDF @lbl (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
                                    
  | StDF      lhs.simm13    = maybe @copy 
                                    (\i -> StDF @lbl1 @lbl2 (C i)) 
                                    (vfind @vlbl.copy @lhs.env)
                                    
  | IfEq      lhs.simm13    = maybe (IfEq @lbl @vlbl.copy @ins1.simm13 @ins2.simm13) 
                                    (\(x,y) -> IfEq x (C y) @ins1.simm13 @ins2.simm13) 
                                    (idsfind @lbl @vlbl.copy @lhs.env)  
  
  | IfLE      lhs.simm13    = maybe (IfLE @lbl @vlbl.copy @ins1.simm13 @ins2.simm13) 
                                    (\(x,y) -> IfLE x (C y) @ins1.simm13 @ins2.simm13) 
                                    (idsfind @lbl @vlbl.copy @lhs.env) 
  
  | IfGE      lhs.simm13    = maybe (IfGE @lbl @vlbl.copy @ins1.simm13 @ins2.simm13) 
                                    (\(x,y) -> IfGE x (C y) @ins1.simm13 @ins2.simm13) 
                                    (idsfind @lbl @vlbl.copy @lhs.env)                                     
                                    
  | * - Add Sub SLL Ld St LdDF StDF IfEq IfLE IfGE 
              lhs.simm13    = @copy
              
                                                  
SEM Fundef
  | Fundef    lhs.simm13    = Fundef @name @args @fargs @body.simm13 @ret.copy

{-
g :: M.M Id Int -> SparcT -> SparcT
g env (Ans expr) = Ans(g' env expr)
g env (Let (x,t) (Set i) e) 
    | (-4096 <= i) && (i < 4096) = let e' = g (M.add x i env) e in
                                   if x `elem` (fv e') 
                                      then Let (x, t)(Set i) e' 
                                      else e'
g env (Let xt (SLL y (C i)) e)       {- for array access -}
    |  M.mem y env    = g env (Let xt (Set ((M.find' y env) `shiftL` i)) e)
g env (Let xt expr e) = Let xt (g' env expr) (g env e)
g env (Forget x e)    = Forget x (g env e)


-} 

{

simm13 :: Prog -> Prog
simm13 prog = simm13_Syn_Prog synthesized
  where
    synthesized = wrap_Prog (sem_Prog prog) inherited
    inherited   = Inh_Prog { env_Inh_Prog = M.empty }

                        
}  
 
        