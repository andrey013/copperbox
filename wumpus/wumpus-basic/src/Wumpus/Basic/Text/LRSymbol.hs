{-# OPTIONS -Wall #-}

--------------------------------------------------------------------------------
-- |
-- Module      :  Wumpus.Basic.Text.LRSymbol
-- Copyright   :  (c) Stephen Tetley 2010
-- License     :  BSD3
--
-- Maintainer  :  Stephen Tetley <stephen.tetley@gmail.com>
-- Stability   :  highly unstable
-- Portability :  GHC
--
-- Named literals from Symbol font, drawn with the LRText monad.
-- 
-- Note - currently the techinique used here generates adequate
-- PostScript, but very ineficient SVG.
-- 
--------------------------------------------------------------------------------

module Wumpus.Basic.Text.LRSymbol
  ( 

    alpha
  , beta
  , gamma
  , delta
  , epsilon
  , zeta
  , eta
  , theta
  , iota
  , kappa
  , lambda
  , mu
  , nu
  , xi
  , pi
  , rho
  , sigma
  , tau
  , upsilon
  , phi
  , chi
  , psi
  , omega

  ) where


import Wumpus.Basic.SafeFonts
import Wumpus.Basic.Text.LRText

import Wumpus.Core                              -- package: wumpus-core

import Prelude hiding ( pi )

-- Note - due to a optimization in Wumpus-Core, the PostScript
-- generated by the techinique here - writing a 
-- (single-character) label one at a time - isn\'t to 
-- inefficient.
--
-- [Wumpus-Core only issues a findfont command
-- when the font changes]. 
-- 
-- However for SVG the result is very poor - one text element 
-- including an orientation changing matrix transforming for 
-- each character.
-- 
-- Wumpus-Core\'s SVG rendering will work at some point.
-- 

useSymbol :: TextM u a -> TextM u a
useSymbol = bracketFontFace symbol




alpha       :: (Num u, FromPtSize u) => TextM u ()
alpha       = useSymbol $ char 'a'

beta        :: (Num u, FromPtSize u) => TextM u ()
beta        = useSymbol $ char 'b'

gamma       :: (Num u, FromPtSize u) => TextM u ()
gamma       = useSymbol $ char 'g'

delta       :: (Num u, FromPtSize u) => TextM u ()
delta       = useSymbol $ char 'd'

epsilon     :: (Num u, FromPtSize u) => TextM u ()
epsilon     = useSymbol $ char 'e'

zeta        :: (Num u, FromPtSize u) => TextM u ()
zeta        = useSymbol $ char 'z'

eta         :: (Num u, FromPtSize u) => TextM u ()
eta         = useSymbol $ char 'h'

theta       :: (Num u, FromPtSize u) => TextM u ()
theta       = useSymbol $ char 'q'

iota        :: (Num u, FromPtSize u) => TextM u ()
iota        = useSymbol $ char 'i'

kappa       :: (Num u, FromPtSize u) => TextM u ()
kappa       = useSymbol $ char 'k'

lambda      :: (Num u, FromPtSize u) => TextM u ()
lambda      = useSymbol $ char 'l'

mu          :: (Num u, FromPtSize u) => TextM u ()
mu          = useSymbol $ char 'm'

nu          :: (Num u, FromPtSize u) => TextM u ()
nu          = useSymbol $ char 'n'

xi          :: (Num u, FromPtSize u) => TextM u ()
xi          = useSymbol $ char 'x'

pi          :: (Num u, FromPtSize u) => TextM u ()
pi          = useSymbol $ char 'p'

rho         :: (Num u, FromPtSize u) => TextM u ()
rho         = useSymbol $ char 'r'

sigma       :: (Num u, FromPtSize u) => TextM u ()
sigma       = useSymbol $ char 's'

tau         :: (Num u, FromPtSize u) => TextM u ()
tau         = useSymbol $ char 't'

upsilon     :: (Num u, FromPtSize u) => TextM u ()
upsilon     = useSymbol $ char 'u'

phi         :: (Num u, FromPtSize u) => TextM u ()
phi         = useSymbol $ char 'j'

chi         :: (Num u, FromPtSize u) => TextM u ()
chi         = useSymbol $ char 'c'

psi         :: (Num u, FromPtSize u) => TextM u ()
psi         = useSymbol $ char 'y'

omega       :: (Num u, FromPtSize u) => TextM u ()
omega       = useSymbol $ char 'w'
