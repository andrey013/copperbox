-- do not edit; automatically generated by UU.AG


module Gen.OutputUuagTypes 
  ( outputUuag
  ) where

import Base.PrimitiveTypes
import Gen.UuagAbsSyn
import Util.PPExt

import PPrint





outputUuag :: Ag -> Doc
outputUuag xs = linespace $ pp_Syn_Ag synthesized
  where synthesized = wrap_Ag (sem_Ag xs) inherited
        inherited   = Inh_Ag
        
-- Field Context - is it printed as part of a tuple or 
-- as one of a constructor fields        
data FCtx = CtxTuple | CtxConstr
  
-- Ag ----------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Ag.Cons:

-}
{-
   local variables for Ag.Nil:

-}
-- semantic domain
type T_Ag = ( ([Doc]))
-- cata
sem_Ag :: (Ag) ->
          (T_Ag)
sem_Ag (list) =
    (Prelude.foldr (sem_Ag_Cons) (sem_Ag_Nil) ((Prelude.map sem_Elem list)))
data Inh_Ag = Inh_Ag {}
data Syn_Ag = Syn_Ag {pp_Syn_Ag :: [Doc]}
wrap_Ag :: (T_Ag) ->
           (Inh_Ag) ->
           (Syn_Ag)
wrap_Ag (sem) ((Inh_Ag )) =
    let ( s1) =
            (sem )
    in  (Syn_Ag (s1))
sem_Ag_Cons :: (T_Elem) ->
               (T_Ag) ->
               (T_Ag)
sem_Ag_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Ag_Nil :: (T_Ag)
sem_Ag_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- DataAlt -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for DataAlt.DataAlt:

-}
-- semantic domain
type T_DataAlt = ( (Doc))
-- cata
sem_DataAlt :: (DataAlt) ->
               (T_DataAlt)
sem_DataAlt ((DataAlt (_name) (_fields))) =
    (sem_DataAlt_DataAlt (_name) ((sem_Fields (_fields))))
data Inh_DataAlt = Inh_DataAlt {}
data Syn_DataAlt = Syn_DataAlt {pp_Syn_DataAlt :: Doc}
wrap_DataAlt :: (T_DataAlt) ->
                (Inh_DataAlt) ->
                (Syn_DataAlt)
wrap_DataAlt (sem) ((Inh_DataAlt )) =
    let ( s1) =
            (sem )
    in  (Syn_DataAlt (s1))
sem_DataAlt_DataAlt :: (Conid) ->
                       (T_Fields) ->
                       (T_DataAlt)
sem_DataAlt_DataAlt (name_) (fields_) =
    let _lhsOpp :: (Doc)
        _fieldsIpp :: ([Doc])
        _fieldsOctx :: (FCtx)
        ( _fieldsIpp) =
            (fields_ (_fieldsOctx))
        -- "OutputUuagTypes.ag"(line 46, column 21)
        (_fieldsOctx@_) =
            CtxConstr
        -- "OutputUuagTypes.ag"(line 44, column 21)
        (_lhsOpp@_) =
            char '|' <+> fill 16 (text name_)
              <+> align (vcat _fieldsIpp)
    in  ( _lhsOpp)
-- DataAlts ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for DataAlts.Cons:

-}
{-
   local variables for DataAlts.Nil:

-}
-- semantic domain
type T_DataAlts = ( ([Doc]))
-- cata
sem_DataAlts :: (DataAlts) ->
                (T_DataAlts)
sem_DataAlts (list) =
    (Prelude.foldr (sem_DataAlts_Cons) (sem_DataAlts_Nil) ((Prelude.map sem_DataAlt list)))
data Inh_DataAlts = Inh_DataAlts {}
data Syn_DataAlts = Syn_DataAlts {pp_Syn_DataAlts :: [Doc]}
wrap_DataAlts :: (T_DataAlts) ->
                 (Inh_DataAlts) ->
                 (Syn_DataAlts)
wrap_DataAlts (sem) ((Inh_DataAlts )) =
    let ( s1) =
            (sem )
    in  (Syn_DataAlts (s1))
sem_DataAlts_Cons :: (T_DataAlt) ->
                     (T_DataAlts) ->
                     (T_DataAlts)
sem_DataAlts_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_DataAlts_Nil :: (T_DataAlts)
sem_DataAlts_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Elem --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Elem.Data:

-}
{-
   local variables for Elem.Type:

-}
-- semantic domain
type T_Elem = ( (Doc))
-- cata
sem_Elem :: (Elem) ->
            (T_Elem)
sem_Elem ((Data (_name) (_alternatives))) =
    (sem_Elem_Data (_name) ((sem_DataAlts (_alternatives))))
sem_Elem ((Type (_name) (_type_body))) =
    (sem_Elem_Type (_name) ((sem_TypeBody (_type_body))))
data Inh_Elem = Inh_Elem {}
data Syn_Elem = Syn_Elem {pp_Syn_Elem :: Doc}
wrap_Elem :: (T_Elem) ->
             (Inh_Elem) ->
             (Syn_Elem)
wrap_Elem (sem) ((Inh_Elem )) =
    let ( s1) =
            (sem )
    in  (Syn_Elem (s1))
sem_Elem_Data :: (Conid) ->
                 (T_DataAlts) ->
                 (T_Elem)
sem_Elem_Data (name_) (alternatives_) =
    let _lhsOpp :: (Doc)
        _alternativesIpp :: ([Doc])
        ( _alternativesIpp) =
            (alternatives_ )
        -- "OutputUuagTypes.ag"(line 29, column 17)
        (_lhsOpp@_) =
            text "DATA" <+> text name_
              <$> indent 2 (vcat _alternativesIpp)
    in  ( _lhsOpp)
sem_Elem_Type :: (Conid) ->
                 (T_TypeBody) ->
                 (T_Elem)
sem_Elem_Type (name_) (type_body_) =
    let _lhsOpp :: (Doc)
        _type_bodyIpp :: (Doc)
        ( _type_bodyIpp) =
            (type_body_ )
        -- "OutputUuagTypes.ag"(line 32, column 17)
        (_lhsOpp@_) =
            text "TYPE" <+> text name_
              <+> equals
              <+> _type_bodyIpp
    in  ( _lhsOpp)
-- Field -------------------------------------------------------
{-
   inherited attributes:
      ctx                  : FCtx

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Field.ConstrField:

-}
{-
   local variables for Field.LabelledField:

-}
-- semantic domain
type T_Field = (FCtx) ->
               ( (Doc))
-- cata
sem_Field :: (Field) ->
             (T_Field)
sem_Field ((ConstrField (_conid))) =
    (sem_Field_ConstrField (_conid))
sem_Field ((LabelledField (_name) (_typ))) =
    (sem_Field_LabelledField (_name) ((sem_Typ (_typ))))
data Inh_Field = Inh_Field {ctx_Inh_Field :: FCtx}
data Syn_Field = Syn_Field {pp_Syn_Field :: Doc}
wrap_Field :: (T_Field) ->
              (Inh_Field) ->
              (Syn_Field)
wrap_Field (sem) ((Inh_Field (i1))) =
    let ( s1) =
            (sem (i1))
    in  (Syn_Field (s1))
sem_Field_ConstrField :: (Conid) ->
                         (T_Field)
sem_Field_ConstrField (conid_) =
    \ _lhsIctx ->
        let _lhsOpp :: (Doc)
            -- "OutputUuagTypes.ag"(line 63, column 21)
            (_lhsOpp@_) =
                text conid_
        in  ( _lhsOpp)
sem_Field_LabelledField :: (Varid) ->
                           (T_Typ) ->
                           (T_Field)
sem_Field_LabelledField (name_) (typ_) =
    \ _lhsIctx ->
        let _lhsOpp :: (Doc)
            _typIpp :: (Doc)
            ( _typIpp) =
                (typ_ )
            -- "OutputUuagTypes.ag"(line 60, column 21)
            (_lhsOpp@_) =
                case _lhsIctx of
                  CtxConstr -> fill 16 (text name_) <+> colon <+> _typIpp
                  CtxTuple -> (text name_) <>colon <> _typIpp
        in  ( _lhsOpp)
-- Fields ------------------------------------------------------
{-
   inherited attributes:
      ctx                  : FCtx

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Fields.Cons:

-}
{-
   local variables for Fields.Nil:

-}
-- semantic domain
type T_Fields = (FCtx) ->
                ( ([Doc]))
-- cata
sem_Fields :: (Fields) ->
              (T_Fields)
sem_Fields (list) =
    (Prelude.foldr (sem_Fields_Cons) (sem_Fields_Nil) ((Prelude.map sem_Field list)))
data Inh_Fields = Inh_Fields {ctx_Inh_Fields :: FCtx}
data Syn_Fields = Syn_Fields {pp_Syn_Fields :: [Doc]}
wrap_Fields :: (T_Fields) ->
               (Inh_Fields) ->
               (Syn_Fields)
wrap_Fields (sem) ((Inh_Fields (i1))) =
    let ( s1) =
            (sem (i1))
    in  (Syn_Fields (s1))
sem_Fields_Cons :: (T_Field) ->
                   (T_Fields) ->
                   (T_Fields)
sem_Fields_Cons (hd_) (tl_) =
    \ _lhsIctx ->
        let _lhsOpp :: ([Doc])
            _hdIpp :: (Doc)
            _hdOctx :: (FCtx)
            _tlIpp :: ([Doc])
            _tlOctx :: (FCtx)
            ( _hdIpp) =
                (hd_ (_hdOctx))
            ( _tlIpp) =
                (tl_ (_tlOctx))
            -- use rule
            (_lhsOpp@_) =
                _hdIpp : _tlIpp
            -- copy rule (down)
            (_hdOctx@_) =
                _lhsIctx
            -- copy rule (down)
            (_tlOctx@_) =
                _lhsIctx
        in  ( _lhsOpp)
sem_Fields_Nil :: (T_Fields)
sem_Fields_Nil  =
    \ _lhsIctx ->
        let _lhsOpp :: ([Doc])
            -- use rule
            (_lhsOpp@_) =
                []
        in  ( _lhsOpp)
-- Typ ---------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Typ.CodeBlock:

-}
{-
   local variables for Typ.NamedType:

-}
-- semantic domain
type T_Typ = ( (Doc))
-- cata
sem_Typ :: (Typ) ->
           (T_Typ)
sem_Typ ((CodeBlock (_codeblock))) =
    (sem_Typ_CodeBlock (_codeblock))
sem_Typ ((NamedType (_conid))) =
    (sem_Typ_NamedType (_conid))
data Inh_Typ = Inh_Typ {}
data Syn_Typ = Syn_Typ {pp_Syn_Typ :: Doc}
wrap_Typ :: (T_Typ) ->
            (Inh_Typ) ->
            (Syn_Typ)
wrap_Typ (sem) ((Inh_Typ )) =
    let ( s1) =
            (sem )
    in  (Syn_Typ (s1))
sem_Typ_CodeBlock :: (String) ->
                     (T_Typ)
sem_Typ_CodeBlock (codeblock_) =
    let _lhsOpp :: (Doc)
        -- "OutputUuagTypes.ag"(line 39, column 22)
        (_lhsOpp@_) =
            braces $ text codeblock_
    in  ( _lhsOpp)
sem_Typ_NamedType :: (Conid) ->
                     (T_Typ)
sem_Typ_NamedType (conid_) =
    let _lhsOpp :: (Doc)
        -- "OutputUuagTypes.ag"(line 38, column 22)
        (_lhsOpp@_) =
            text conid_
    in  ( _lhsOpp)
-- TypeBody ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TypeBody.TB_List:

-}
{-
   local variables for TypeBody.TB_Maybe:

-}
{-
   local variables for TypeBody.TB_Tuple:

-}
-- semantic domain
type T_TypeBody = ( (Doc))
-- cata
sem_TypeBody :: (TypeBody) ->
                (T_TypeBody)
sem_TypeBody ((TB_List (_typ))) =
    (sem_TypeBody_TB_List ((sem_Typ (_typ))))
sem_TypeBody ((TB_Maybe (_typ))) =
    (sem_TypeBody_TB_Maybe ((sem_Typ (_typ))))
sem_TypeBody ((TB_Tuple (_fields))) =
    (sem_TypeBody_TB_Tuple ((sem_Fields (_fields))))
data Inh_TypeBody = Inh_TypeBody {}
data Syn_TypeBody = Syn_TypeBody {pp_Syn_TypeBody :: Doc}
wrap_TypeBody :: (T_TypeBody) ->
                 (Inh_TypeBody) ->
                 (Syn_TypeBody)
wrap_TypeBody (sem) ((Inh_TypeBody )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeBody (s1))
sem_TypeBody_TB_List :: (T_Typ) ->
                        (T_TypeBody)
sem_TypeBody_TB_List (typ_) =
    let _lhsOpp :: (Doc)
        _typIpp :: (Doc)
        ( _typIpp) =
            (typ_ )
        -- "OutputUuagTypes.ag"(line 49, column 21)
        (_lhsOpp@_) =
            brackets _typIpp
    in  ( _lhsOpp)
sem_TypeBody_TB_Maybe :: (T_Typ) ->
                         (T_TypeBody)
sem_TypeBody_TB_Maybe (typ_) =
    let _lhsOpp :: (Doc)
        _typIpp :: (Doc)
        ( _typIpp) =
            (typ_ )
        -- "OutputUuagTypes.ag"(line 50, column 21)
        (_lhsOpp@_) =
            text "MAYBE" <+> _typIpp
    in  ( _lhsOpp)
sem_TypeBody_TB_Tuple :: (T_Fields) ->
                         (T_TypeBody)
sem_TypeBody_TB_Tuple (fields_) =
    let _lhsOpp :: (Doc)
        _fieldsIpp :: ([Doc])
        _fieldsOctx :: (FCtx)
        ( _fieldsIpp) =
            (fields_ (_fieldsOctx))
        -- "OutputUuagTypes.ag"(line 52, column 21)
        (_fieldsOctx@_) =
            CtxTuple
        -- "OutputUuagTypes.ag"(line 51, column 21)
        (_lhsOpp@_) =
            tupled _fieldsIpp
    in  ( _lhsOpp)


