-- do not edit; automatically generated by UU.AG

module Gen.OutputOCamlExpr
  ( outputOCamlExprs
  ) where

import Base.PrimitiveTypes

import Gen.OCamlAbsSyn

import Util.PPExt

import PPrint




manySpaced []   = empty
manySpaced xs   = space <> hsep xs

optWhen (Just doc)  = space <> text "when" <+> doc
optWhen Nothing     = empty 


optElse (Just doc)  = space <> text "else" <+> doc
optElse Nothing     = empty 

optIn (Just doc)  = space <> text "in" <+> doc
optIn Nothing     = empty 

optColon (Just doc)  = space <> colon <+> doc
optColon Nothing     = empty 

prefix (Just str) = text str <> dot
prefix Nothing    = empty

outputOCamlExprs :: Program -> Doc
outputOCamlExprs prog = pp_Syn_Program synthesized
  where synthesized = wrap_Program (sem_Program prog) inherited
        inherited   = Inh_Program


          
-- Argument ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Argument.ArgExpr:

-}
-- semantic domain
type T_Argument = ( (Doc))
-- cata
sem_Argument :: (Argument) ->
                (T_Argument)
sem_Argument ((ArgExpr (_expr))) =
    (sem_Argument_ArgExpr ((sem_Expr (_expr))))
data Inh_Argument = Inh_Argument {}
data Syn_Argument = Syn_Argument {pp_Syn_Argument :: Doc}
wrap_Argument :: (T_Argument) ->
                 (Inh_Argument) ->
                 (Syn_Argument)
wrap_Argument (sem) ((Inh_Argument )) =
    let ( s1) =
            (sem )
    in  (Syn_Argument (s1))
sem_Argument_ArgExpr :: (T_Expr) ->
                        (T_Argument)
sem_Argument_ArgExpr (expr_) =
    let _lhsOpp :: (Doc)
        _exprIpp :: (Doc)
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 146, column 21)
        (_lhsOpp@_) =
            _exprIpp
    in  ( _lhsOpp)
-- Arguments ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Arguments.Cons:

-}
{-
   local variables for Arguments.Nil:

-}
-- semantic domain
type T_Arguments = ( ([Doc]))
-- cata
sem_Arguments :: (Arguments) ->
                 (T_Arguments)
sem_Arguments (list) =
    (Prelude.foldr (sem_Arguments_Cons) (sem_Arguments_Nil) ((Prelude.map sem_Argument list)))
data Inh_Arguments = Inh_Arguments {}
data Syn_Arguments = Syn_Arguments {pp_Syn_Arguments :: [Doc]}
wrap_Arguments :: (T_Arguments) ->
                  (Inh_Arguments) ->
                  (Syn_Arguments)
wrap_Arguments (sem) ((Inh_Arguments )) =
    let ( s1) =
            (sem )
    in  (Syn_Arguments (s1))
sem_Arguments_Cons :: (T_Argument) ->
                      (T_Arguments) ->
                      (T_Arguments)
sem_Arguments_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Arguments_Nil :: (T_Arguments)
sem_Arguments_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Constant ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Constant.FloatLiteral:

-}
{-
   local variables for Constant.IntegerLiteral:

-}
{-
   local variables for Constant.Nil:

-}
{-
   local variables for Constant.StringLiteral:

-}
{-
   local variables for Constant.Unit:

-}
{-
   local variables for Constant.Val_False:

-}
{-
   local variables for Constant.Val_True:

-}
-- semantic domain
type T_Constant = ( (Doc))
-- cata
sem_Constant :: (Constant) ->
                (T_Constant)
sem_Constant ((FloatLiteral (_value))) =
    (sem_Constant_FloatLiteral (_value))
sem_Constant ((IntegerLiteral (_value))) =
    (sem_Constant_IntegerLiteral (_value))
sem_Constant ((Nil )) =
    (sem_Constant_Nil )
sem_Constant ((StringLiteral (_value))) =
    (sem_Constant_StringLiteral (_value))
sem_Constant ((Unit )) =
    (sem_Constant_Unit )
sem_Constant ((Val_False )) =
    (sem_Constant_Val_False )
sem_Constant ((Val_True )) =
    (sem_Constant_Val_True )
data Inh_Constant = Inh_Constant {}
data Syn_Constant = Syn_Constant {pp_Syn_Constant :: Doc}
wrap_Constant :: (T_Constant) ->
                 (Inh_Constant) ->
                 (Syn_Constant)
wrap_Constant (sem) ((Inh_Constant )) =
    let ( s1) =
            (sem )
    in  (Syn_Constant (s1))
sem_Constant_FloatLiteral :: (Float) ->
                             (T_Constant)
sem_Constant_FloatLiteral (value_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 81, column 23)
        (_lhsOpp@_) =
            float value_
    in  ( _lhsOpp)
sem_Constant_IntegerLiteral :: (Int) ->
                               (T_Constant)
sem_Constant_IntegerLiteral (value_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 80, column 23)
        (_lhsOpp@_) =
            int value_
    in  ( _lhsOpp)
sem_Constant_Nil :: (T_Constant)
sem_Constant_Nil  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 86, column 23)
        (_lhsOpp@_) =
            text "[]"
    in  ( _lhsOpp)
sem_Constant_StringLiteral :: (String) ->
                              (T_Constant)
sem_Constant_StringLiteral (value_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 82, column 23)
        (_lhsOpp@_) =
            dquotes (text value_)
    in  ( _lhsOpp)
sem_Constant_Unit :: (T_Constant)
sem_Constant_Unit  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 85, column 23)
        (_lhsOpp@_) =
            text "()"
    in  ( _lhsOpp)
sem_Constant_Val_False :: (T_Constant)
sem_Constant_Val_False  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 84, column 23)
        (_lhsOpp@_) =
            text "false"
    in  ( _lhsOpp)
sem_Constant_Val_True :: (T_Constant)
sem_Constant_Val_True  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 83, column 23)
        (_lhsOpp@_) =
            text "true"
    in  ( _lhsOpp)
-- Constr ------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Constr.Tuple:

-}
-- semantic domain
type T_Constr = ( (Doc))
-- cata
sem_Constr :: (Constr) ->
              (T_Constr)
sem_Constr (( module_path,constr_name)) =
    (sem_Constr_Tuple ((sem_OptIdentifier (module_path))) (constr_name))
data Inh_Constr = Inh_Constr {}
data Syn_Constr = Syn_Constr {pp_Syn_Constr :: Doc}
wrap_Constr :: (T_Constr) ->
               (Inh_Constr) ->
               (Syn_Constr)
wrap_Constr (sem) ((Inh_Constr )) =
    let ( s1) =
            (sem )
    in  (Syn_Constr (s1))
sem_Constr_Tuple :: (T_OptIdentifier) ->
                    (String) ->
                    (T_Constr)
sem_Constr_Tuple (module_path_) (constr_name_) =
    let _lhsOpp :: (Doc)
        _module_pathIidentity :: (OptIdentifier)
        ( _module_pathIidentity) =
            (module_path_ )
        -- "OutputOCamlExpr.ag"(line 89, column 21)
        (_lhsOpp@_) =
            prefix _module_pathIidentity <> text constr_name_
    in  ( _lhsOpp)
-- ConstrDecl --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for ConstrDecl.Tuple:

-}
-- semantic domain
type T_ConstrDecl = ( )
-- cata
sem_ConstrDecl :: (ConstrDecl) ->
                  (T_ConstrDecl)
sem_ConstrDecl (( constr_name,opt_type_expr)) =
    (sem_ConstrDecl_Tuple (constr_name) ((sem_OptTypeExpr (opt_type_expr))))
data Inh_ConstrDecl = Inh_ConstrDecl {}
data Syn_ConstrDecl = Syn_ConstrDecl {}
wrap_ConstrDecl :: (T_ConstrDecl) ->
                   (Inh_ConstrDecl) ->
                   (Syn_ConstrDecl)
wrap_ConstrDecl (sem) ((Inh_ConstrDecl )) =
    let 
    in  (Syn_ConstrDecl )
sem_ConstrDecl_Tuple :: (String) ->
                        (T_OptTypeExpr) ->
                        (T_ConstrDecl)
sem_ConstrDecl_Tuple (constr_name_) (opt_type_expr_) =
    let _opt_type_exprIpp :: ((Maybe Doc))
        ( _opt_type_exprIpp) =
            (opt_type_expr_ )
    in  ( )
-- ConstrDecls -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for ConstrDecls.Cons:

-}
{-
   local variables for ConstrDecls.Nil:

-}
-- semantic domain
type T_ConstrDecls = ( )
-- cata
sem_ConstrDecls :: (ConstrDecls) ->
                   (T_ConstrDecls)
sem_ConstrDecls (list) =
    (Prelude.foldr (sem_ConstrDecls_Cons) (sem_ConstrDecls_Nil) ((Prelude.map sem_ConstrDecl list)))
data Inh_ConstrDecls = Inh_ConstrDecls {}
data Syn_ConstrDecls = Syn_ConstrDecls {}
wrap_ConstrDecls :: (T_ConstrDecls) ->
                    (Inh_ConstrDecls) ->
                    (Syn_ConstrDecls)
wrap_ConstrDecls (sem) ((Inh_ConstrDecls )) =
    let 
    in  (Syn_ConstrDecls )
sem_ConstrDecls_Cons :: (T_ConstrDecl) ->
                        (T_ConstrDecls) ->
                        (T_ConstrDecls)
sem_ConstrDecls_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_ConstrDecls_Nil :: (T_ConstrDecls)
sem_ConstrDecls_Nil  =
    let 
    in  ( )
-- Def ---------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Def.MLet:

-}
{-
   local variables for Def.MLetrec:

-}
-- semantic domain
type T_Def = ( (Doc))
-- cata
sem_Def :: (Def) ->
           (T_Def)
sem_Def ((MLet (_binds))) =
    (sem_Def_MLet ((sem_LetBindings (_binds))))
sem_Def ((MLetrec (_binds))) =
    (sem_Def_MLetrec ((sem_LetBindings (_binds))))
data Inh_Def = Inh_Def {}
data Syn_Def = Syn_Def {pp_Syn_Def :: Doc}
wrap_Def :: (T_Def) ->
            (Inh_Def) ->
            (Syn_Def)
wrap_Def (sem) ((Inh_Def )) =
    let ( s1) =
            (sem )
    in  (Syn_Def (s1))
sem_Def_MLet :: (T_LetBindings) ->
                (T_Def)
sem_Def_MLet (binds_) =
    let _lhsOpp :: (Doc)
        _bindsIpp :: ([Doc])
        ( _bindsIpp) =
            (binds_ )
        -- "OutputOCamlExpr.ag"(line 38, column 21)
        (_lhsOpp@_) =
            encloseSep (text "let ")
                       empty
                       (text " and ")
                       _bindsIpp
    in  ( _lhsOpp)
sem_Def_MLetrec :: (T_LetBindings) ->
                   (T_Def)
sem_Def_MLetrec (binds_) =
    let _lhsOpp :: (Doc)
        _bindsIpp :: ([Doc])
        ( _bindsIpp) =
            (binds_ )
        -- "OutputOCamlExpr.ag"(line 42, column 21)
        (_lhsOpp@_) =
            encloseSep (text "let rec ")
                       empty
                       (text " and ")
                       _bindsIpp
    in  ( _lhsOpp)
-- Defs --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Defs.Cons:

-}
{-
   local variables for Defs.Nil:

-}
-- semantic domain
type T_Defs = ( ([Doc]))
-- cata
sem_Defs :: (Defs) ->
            (T_Defs)
sem_Defs (list) =
    (Prelude.foldr (sem_Defs_Cons) (sem_Defs_Nil) ((Prelude.map sem_Def list)))
data Inh_Defs = Inh_Defs {}
data Syn_Defs = Syn_Defs {pp_Syn_Defs :: [Doc]}
wrap_Defs :: (T_Defs) ->
             (Inh_Defs) ->
             (Syn_Defs)
wrap_Defs (sem) ((Inh_Defs )) =
    let ( s1) =
            (sem )
    in  (Syn_Defs (s1))
sem_Defs_Cons :: (T_Def) ->
                 (T_Defs) ->
                 (T_Defs)
sem_Defs_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Defs_Nil :: (T_Defs)
sem_Defs_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Expr --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Expr.App:

-}
{-
   local variables for Expr.ConstantExpr:

-}
{-
   local variables for Expr.ConstrApp:

-}
{-
   local variables for Expr.FieldAccess:

-}
{-
   local variables for Expr.IfExpr:

-}
{-
   local variables for Expr.Let:

-}
{-
   local variables for Expr.Letrec:

-}
{-
   local variables for Expr.ListExpr:

-}
{-
   local variables for Expr.Match:

-}
{-
   local variables for Expr.ParenExpr:

-}
{-
   local variables for Expr.Seq:

-}
{-
   local variables for Expr.TupleExpr:

-}
{-
   local variables for Expr.ValuePathExpr:

-}
-- semantic domain
type T_Expr = ( (Doc))
-- cata
sem_Expr :: (Expr) ->
            (T_Expr)
sem_Expr ((App (_expr) (_args))) =
    (sem_Expr_App ((sem_Expr (_expr))) ((sem_Arguments (_args))))
sem_Expr ((ConstantExpr (_value))) =
    (sem_Expr_ConstantExpr ((sem_Constant (_value))))
sem_Expr ((ConstrApp (_constr) (_expr))) =
    (sem_Expr_ConstrApp ((sem_Constr (_constr))) ((sem_Expr (_expr))))
sem_Expr ((FieldAccess (_expr) (_field))) =
    (sem_Expr_FieldAccess ((sem_Expr (_expr))) ((sem_Field (_field))))
sem_Expr ((IfExpr (_cond_expr) (_then_expr) (_opt_else))) =
    (sem_Expr_IfExpr ((sem_Expr (_cond_expr))) ((sem_Expr (_then_expr))) ((sem_OptExpr (_opt_else))))
sem_Expr ((Let (_binds) (_expr))) =
    (sem_Expr_Let ((sem_LetBindings (_binds))) ((sem_Expr (_expr))))
sem_Expr ((Letrec (_binds) (_expr))) =
    (sem_Expr_Letrec ((sem_LetBindings (_binds))) ((sem_Expr (_expr))))
sem_Expr ((ListExpr (_exprs))) =
    (sem_Expr_ListExpr ((sem_Exprs (_exprs))))
sem_Expr ((Match (_expr) (_pat_match))) =
    (sem_Expr_Match ((sem_Expr (_expr))) ((sem_PatternMatching (_pat_match))))
sem_Expr ((ParenExpr (_expr))) =
    (sem_Expr_ParenExpr ((sem_Expr (_expr))))
sem_Expr ((Seq (_expr1) (_expr2))) =
    (sem_Expr_Seq ((sem_Expr (_expr1))) ((sem_Expr (_expr2))))
sem_Expr ((TupleExpr (_exprs))) =
    (sem_Expr_TupleExpr ((sem_Exprs (_exprs))))
sem_Expr ((ValuePathExpr (_value_path))) =
    (sem_Expr_ValuePathExpr ((sem_ValuePath (_value_path))))
data Inh_Expr = Inh_Expr {}
data Syn_Expr = Syn_Expr {pp_Syn_Expr :: Doc}
wrap_Expr :: (T_Expr) ->
             (Inh_Expr) ->
             (Syn_Expr)
wrap_Expr (sem) ((Inh_Expr )) =
    let ( s1) =
            (sem )
    in  (Syn_Expr (s1))
sem_Expr_App :: (T_Expr) ->
                (T_Arguments) ->
                (T_Expr)
sem_Expr_App (expr_) (args_) =
    let _lhsOpp :: (Doc)
        _exprIpp :: (Doc)
        _argsIpp :: ([Doc])
        ( _exprIpp) =
            (expr_ )
        ( _argsIpp) =
            (args_ )
        -- "OutputOCamlExpr.ag"(line 53, column 21)
        (_lhsOpp@_) =
            _exprIpp <> manySpaced _argsIpp
    in  ( _lhsOpp)
sem_Expr_ConstantExpr :: (T_Constant) ->
                         (T_Expr)
sem_Expr_ConstantExpr (value_) =
    let _lhsOpp :: (Doc)
        _valueIpp :: (Doc)
        ( _valueIpp) =
            (value_ )
        -- "OutputOCamlExpr.ag"(line 48, column 21)
        (_lhsOpp@_) =
            _valueIpp
    in  ( _lhsOpp)
sem_Expr_ConstrApp :: (T_Constr) ->
                      (T_Expr) ->
                      (T_Expr)
sem_Expr_ConstrApp (constr_) (expr_) =
    let _lhsOpp :: (Doc)
        _constrIpp :: (Doc)
        _exprIpp :: (Doc)
        ( _constrIpp) =
            (constr_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 51, column 21)
        (_lhsOpp@_) =
            _constrIpp <+> _exprIpp
    in  ( _lhsOpp)
sem_Expr_FieldAccess :: (T_Expr) ->
                        (T_Field) ->
                        (T_Expr)
sem_Expr_FieldAccess (expr_) (field_) =
    let _lhsOpp :: (Doc)
        _exprIpp :: (Doc)
        _fieldIpp :: (Doc)
        ( _exprIpp) =
            (expr_ )
        ( _fieldIpp) =
            (field_ )
        -- "OutputOCamlExpr.ag"(line 54, column 21)
        (_lhsOpp@_) =
            _exprIpp <.> _fieldIpp
    in  ( _lhsOpp)
sem_Expr_IfExpr :: (T_Expr) ->
                   (T_Expr) ->
                   (T_OptExpr) ->
                   (T_Expr)
sem_Expr_IfExpr (cond_expr_) (then_expr_) (opt_else_) =
    let _lhsOpp :: (Doc)
        _cond_exprIpp :: (Doc)
        _then_exprIpp :: (Doc)
        _opt_elseIpp :: ((Maybe Doc))
        ( _cond_exprIpp) =
            (cond_expr_ )
        ( _then_exprIpp) =
            (then_expr_ )
        ( _opt_elseIpp) =
            (opt_else_ )
        -- "OutputOCamlExpr.ag"(line 55, column 21)
        (_lhsOpp@_) =
            text "if" <+> _cond_exprIpp
            <+> text "then" <+> _then_exprIpp
            <> optElse _opt_elseIpp
    in  ( _lhsOpp)
sem_Expr_Let :: (T_LetBindings) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Let (binds_) (expr_) =
    let _lhsOpp :: (Doc)
        _bindsIpp :: ([Doc])
        _exprIpp :: (Doc)
        ( _bindsIpp) =
            (binds_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 61, column 21)
        (_lhsOpp@_) =
            encloseSep (text "let ")
                       empty
                       (text "and ")
                       _bindsIpp
            <+> text "in" <+> _exprIpp
    in  ( _lhsOpp)
sem_Expr_Letrec :: (T_LetBindings) ->
                   (T_Expr) ->
                   (T_Expr)
sem_Expr_Letrec (binds_) (expr_) =
    let _lhsOpp :: (Doc)
        _bindsIpp :: ([Doc])
        _exprIpp :: (Doc)
        ( _bindsIpp) =
            (binds_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 67, column 21)
        (_lhsOpp@_) =
            encloseSep (text "let rec ")
                       empty
                       (line <> text "and ")
                       _bindsIpp
            <+> text "in" <+> _exprIpp
    in  ( _lhsOpp)
sem_Expr_ListExpr :: (T_Exprs) ->
                     (T_Expr)
sem_Expr_ListExpr (exprs_) =
    let _lhsOpp :: (Doc)
        _exprsIpp :: ([Doc])
        ( _exprsIpp) =
            (exprs_ )
        -- "OutputOCamlExpr.ag"(line 52, column 21)
        (_lhsOpp@_) =
            encloseSep lbracket rbracket semi _exprsIpp
    in  ( _lhsOpp)
sem_Expr_Match :: (T_Expr) ->
                  (T_PatternMatching) ->
                  (T_Expr)
sem_Expr_Match (expr_) (pat_match_) =
    let _lhsOpp :: (Doc)
        _exprIpp :: (Doc)
        _pat_matchIpp :: ([Doc])
        ( _exprIpp) =
            (expr_ )
        ( _pat_matchIpp) =
            (pat_match_ )
        -- "OutputOCamlExpr.ag"(line 59, column 21)
        (_lhsOpp@_) =
            matchWith _exprIpp _pat_matchIpp
    in  ( _lhsOpp)
sem_Expr_ParenExpr :: (T_Expr) ->
                      (T_Expr)
sem_Expr_ParenExpr (expr_) =
    let _lhsOpp :: (Doc)
        _exprIpp :: (Doc)
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 49, column 21)
        (_lhsOpp@_) =
            parens $ _exprIpp
    in  ( _lhsOpp)
sem_Expr_Seq :: (T_Expr) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Seq (expr1_) (expr2_) =
    let _lhsOpp :: (Doc)
        _expr1Ipp :: (Doc)
        _expr2Ipp :: (Doc)
        ( _expr1Ipp) =
            (expr1_ )
        ( _expr2Ipp) =
            (expr2_ )
        -- "OutputOCamlExpr.ag"(line 58, column 21)
        (_lhsOpp@_) =
            align (_expr1Ipp <+> semi <> line <> _expr2Ipp)
    in  ( _lhsOpp)
sem_Expr_TupleExpr :: (T_Exprs) ->
                      (T_Expr)
sem_Expr_TupleExpr (exprs_) =
    let _lhsOpp :: (Doc)
        _exprsIpp :: ([Doc])
        ( _exprsIpp) =
            (exprs_ )
        -- "OutputOCamlExpr.ag"(line 50, column 21)
        (_lhsOpp@_) =
            tupled _exprsIpp
    in  ( _lhsOpp)
sem_Expr_ValuePathExpr :: (T_ValuePath) ->
                          (T_Expr)
sem_Expr_ValuePathExpr (value_path_) =
    let _lhsOpp :: (Doc)
        _value_pathIpp :: (Doc)
        ( _value_pathIpp) =
            (value_path_ )
        -- "OutputOCamlExpr.ag"(line 47, column 21)
        (_lhsOpp@_) =
            _value_pathIpp
    in  ( _lhsOpp)
-- Exprs -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Exprs.Cons:

-}
{-
   local variables for Exprs.Nil:

-}
-- semantic domain
type T_Exprs = ( ([Doc]))
-- cata
sem_Exprs :: (Exprs) ->
             (T_Exprs)
sem_Exprs (list) =
    (Prelude.foldr (sem_Exprs_Cons) (sem_Exprs_Nil) ((Prelude.map sem_Expr list)))
data Inh_Exprs = Inh_Exprs {}
data Syn_Exprs = Syn_Exprs {pp_Syn_Exprs :: [Doc]}
wrap_Exprs :: (T_Exprs) ->
              (Inh_Exprs) ->
              (Syn_Exprs)
wrap_Exprs (sem) ((Inh_Exprs )) =
    let ( s1) =
            (sem )
    in  (Syn_Exprs (s1))
sem_Exprs_Cons :: (T_Expr) ->
                  (T_Exprs) ->
                  (T_Exprs)
sem_Exprs_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Exprs_Nil :: (T_Exprs)
sem_Exprs_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Field -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Field.Tuple:

-}
-- semantic domain
type T_Field = ( (Doc))
-- cata
sem_Field :: (Field) ->
             (T_Field)
sem_Field (( module_path,field_name)) =
    (sem_Field_Tuple ((sem_OptIdentifier (module_path))) (field_name))
data Inh_Field = Inh_Field {}
data Syn_Field = Syn_Field {pp_Syn_Field :: Doc}
wrap_Field :: (T_Field) ->
              (Inh_Field) ->
              (Syn_Field)
wrap_Field (sem) ((Inh_Field )) =
    let ( s1) =
            (sem )
    in  (Syn_Field (s1))
sem_Field_Tuple :: (T_OptIdentifier) ->
                   (String) ->
                   (T_Field)
sem_Field_Tuple (module_path_) (field_name_) =
    let _lhsOpp :: (Doc)
        _module_pathIidentity :: (OptIdentifier)
        ( _module_pathIidentity) =
            (module_path_ )
        -- "OutputOCamlExpr.ag"(line 93, column 21)
        (_lhsOpp@_) =
            prefix _module_pathIidentity <> text field_name_
    in  ( _lhsOpp)
-- FieldDecl ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for FieldDecl.Tuple:

-}
-- semantic domain
type T_FieldDecl = ( )
-- cata
sem_FieldDecl :: (FieldDecl) ->
                 (T_FieldDecl)
sem_FieldDecl (( field_name,ty_expr)) =
    (sem_FieldDecl_Tuple (field_name) ((sem_TypeExpr (ty_expr))))
data Inh_FieldDecl = Inh_FieldDecl {}
data Syn_FieldDecl = Syn_FieldDecl {}
wrap_FieldDecl :: (T_FieldDecl) ->
                  (Inh_FieldDecl) ->
                  (Syn_FieldDecl)
wrap_FieldDecl (sem) ((Inh_FieldDecl )) =
    let 
    in  (Syn_FieldDecl )
sem_FieldDecl_Tuple :: (String) ->
                       (T_TypeExpr) ->
                       (T_FieldDecl)
sem_FieldDecl_Tuple (field_name_) (ty_expr_) =
    let _ty_exprIpp :: (Doc)
        ( _ty_exprIpp) =
            (ty_expr_ )
    in  ( )
-- FieldDecls --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for FieldDecls.Cons:

-}
{-
   local variables for FieldDecls.Nil:

-}
-- semantic domain
type T_FieldDecls = ( )
-- cata
sem_FieldDecls :: (FieldDecls) ->
                  (T_FieldDecls)
sem_FieldDecls (list) =
    (Prelude.foldr (sem_FieldDecls_Cons) (sem_FieldDecls_Nil) ((Prelude.map sem_FieldDecl list)))
data Inh_FieldDecls = Inh_FieldDecls {}
data Syn_FieldDecls = Syn_FieldDecls {}
wrap_FieldDecls :: (T_FieldDecls) ->
                   (Inh_FieldDecls) ->
                   (Syn_FieldDecls)
wrap_FieldDecls (sem) ((Inh_FieldDecls )) =
    let 
    in  (Syn_FieldDecls )
sem_FieldDecls_Cons :: (T_FieldDecl) ->
                       (T_FieldDecls) ->
                       (T_FieldDecls)
sem_FieldDecls_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_FieldDecls_Nil :: (T_FieldDecls)
sem_FieldDecls_Nil  =
    let 
    in  ( )
-- LetBinding --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for LetBinding.PatternBinding:

-}
{-
   local variables for LetBinding.ValueBinding:

-}
-- semantic domain
type T_LetBinding = ( (Doc))
-- cata
sem_LetBinding :: (LetBinding) ->
                  (T_LetBinding)
sem_LetBinding ((PatternBinding (_pat) (_expr))) =
    (sem_LetBinding_PatternBinding ((sem_Pattern (_pat))) ((sem_Expr (_expr))))
sem_LetBinding ((ValueBinding (_val_name) (_params) (_opt_ty) (_expr))) =
    (sem_LetBinding_ValueBinding (_val_name) ((sem_Parameters (_params))) ((sem_OptTypeExpr (_opt_ty))) ((sem_Expr (_expr))))
data Inh_LetBinding = Inh_LetBinding {}
data Syn_LetBinding = Syn_LetBinding {pp_Syn_LetBinding :: Doc}
wrap_LetBinding :: (T_LetBinding) ->
                   (Inh_LetBinding) ->
                   (Syn_LetBinding)
wrap_LetBinding (sem) ((Inh_LetBinding )) =
    let ( s1) =
            (sem )
    in  (Syn_LetBinding (s1))
sem_LetBinding_PatternBinding :: (T_Pattern) ->
                                 (T_Expr) ->
                                 (T_LetBinding)
sem_LetBinding_PatternBinding (pat_) (expr_) =
    let _lhsOpp :: (Doc)
        _patIpp :: (Doc)
        _exprIpp :: (Doc)
        ( _patIpp) =
            (pat_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 106, column 21)
        (_lhsOpp@_) =
            _patIpp <=> _exprIpp
    in  ( _lhsOpp)
sem_LetBinding_ValueBinding :: (String) ->
                               (T_Parameters) ->
                               (T_OptTypeExpr) ->
                               (T_Expr) ->
                               (T_LetBinding)
sem_LetBinding_ValueBinding (val_name_) (params_) (opt_ty_) (expr_) =
    let _lhsOpp :: (Doc)
        _paramsIpp :: ([Doc])
        _opt_tyIpp :: ((Maybe Doc))
        _exprIpp :: (Doc)
        ( _paramsIpp) =
            (params_ )
        ( _opt_tyIpp) =
            (opt_ty_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 107, column 21)
        (_lhsOpp@_) =
            text val_name_
             <> manySpaced _paramsIpp
             <> optColon _opt_tyIpp
             <=> _exprIpp
    in  ( _lhsOpp)
-- LetBindings -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for LetBindings.Cons:

-}
{-
   local variables for LetBindings.Nil:

-}
-- semantic domain
type T_LetBindings = ( ([Doc]))
-- cata
sem_LetBindings :: (LetBindings) ->
                   (T_LetBindings)
sem_LetBindings (list) =
    (Prelude.foldr (sem_LetBindings_Cons) (sem_LetBindings_Nil) ((Prelude.map sem_LetBinding list)))
data Inh_LetBindings = Inh_LetBindings {}
data Syn_LetBindings = Syn_LetBindings {pp_Syn_LetBindings :: [Doc]}
wrap_LetBindings :: (T_LetBindings) ->
                    (Inh_LetBindings) ->
                    (Syn_LetBindings)
wrap_LetBindings (sem) ((Inh_LetBindings )) =
    let ( s1) =
            (sem )
    in  (Syn_LetBindings (s1))
sem_LetBindings_Cons :: (T_LetBinding) ->
                        (T_LetBindings) ->
                        (T_LetBindings)
sem_LetBindings_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_LetBindings_Nil :: (T_LetBindings)
sem_LetBindings_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- OptExpr -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : (Maybe Doc)

-}
{-
   local variables for OptExpr.Just:

-}
{-
   local variables for OptExpr.Nothing:

-}
-- semantic domain
type T_OptExpr = ( ((Maybe Doc)))
-- cata
sem_OptExpr :: (OptExpr) ->
               (T_OptExpr)
sem_OptExpr ((Prelude.Just (x))) =
    (sem_OptExpr_Just ((sem_Expr (x))))
sem_OptExpr (Prelude.Nothing) =
    sem_OptExpr_Nothing
data Inh_OptExpr = Inh_OptExpr {}
data Syn_OptExpr = Syn_OptExpr {pp_Syn_OptExpr :: (Maybe Doc)}
wrap_OptExpr :: (T_OptExpr) ->
                (Inh_OptExpr) ->
                (Syn_OptExpr)
wrap_OptExpr (sem) ((Inh_OptExpr )) =
    let ( s1) =
            (sem )
    in  (Syn_OptExpr (s1))
sem_OptExpr_Just :: (T_Expr) ->
                    (T_OptExpr)
sem_OptExpr_Just (just_) =
    let _lhsOpp :: ((Maybe Doc))
        _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
        -- "OutputOCamlExpr.ag"(line 76, column 21)
        (_lhsOpp@_) =
            Just $ _justIpp
    in  ( _lhsOpp)
sem_OptExpr_Nothing :: (T_OptExpr)
sem_OptExpr_Nothing  =
    let _lhsOpp :: ((Maybe Doc))
        -- "OutputOCamlExpr.ag"(line 77, column 21)
        (_lhsOpp@_) =
            Nothing
    in  ( _lhsOpp)
-- OptIdentifier -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      identity             : SELF

-}
{-
   local variables for OptIdentifier.Tuple:
      identity

-}
-- semantic domain
type T_OptIdentifier = ( (OptIdentifier))
-- cata
sem_OptIdentifier :: (OptIdentifier) ->
                     (T_OptIdentifier)
sem_OptIdentifier (( name)) =
    (sem_OptIdentifier_Tuple (name))
data Inh_OptIdentifier = Inh_OptIdentifier {}
data Syn_OptIdentifier = Syn_OptIdentifier {identity_Syn_OptIdentifier :: OptIdentifier}
wrap_OptIdentifier :: (T_OptIdentifier) ->
                      (Inh_OptIdentifier) ->
                      (Syn_OptIdentifier)
wrap_OptIdentifier (sem) ((Inh_OptIdentifier )) =
    let ( s1) =
            (sem )
    in  (Syn_OptIdentifier (s1))
sem_OptIdentifier_Tuple :: ((Maybe String)) ->
                           (T_OptIdentifier)
sem_OptIdentifier_Tuple (name_) =
    let _lhsOidentity :: (OptIdentifier)
        -- self rule
        (_identity@_) =
            (name_)
        -- self rule
        (_lhsOidentity@_) =
            _identity
    in  ( _lhsOidentity)
-- OptTyEquation -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptTyEquation.Just:

-}
{-
   local variables for OptTyEquation.Nothing:

-}
-- semantic domain
type T_OptTyEquation = ( )
-- cata
sem_OptTyEquation :: (OptTyEquation) ->
                     (T_OptTyEquation)
sem_OptTyEquation ((Prelude.Just (x))) =
    (sem_OptTyEquation_Just ((sem_TypeExpr (x))))
sem_OptTyEquation (Prelude.Nothing) =
    sem_OptTyEquation_Nothing
data Inh_OptTyEquation = Inh_OptTyEquation {}
data Syn_OptTyEquation = Syn_OptTyEquation {}
wrap_OptTyEquation :: (T_OptTyEquation) ->
                      (Inh_OptTyEquation) ->
                      (Syn_OptTyEquation)
wrap_OptTyEquation (sem) ((Inh_OptTyEquation )) =
    let 
    in  (Syn_OptTyEquation )
sem_OptTyEquation_Just :: (T_TypeExpr) ->
                          (T_OptTyEquation)
sem_OptTyEquation_Just (just_) =
    let _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
    in  ( )
sem_OptTyEquation_Nothing :: (T_OptTyEquation)
sem_OptTyEquation_Nothing  =
    let 
    in  ( )
-- OptTyRep ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptTyRep.Just:

-}
{-
   local variables for OptTyRep.Nothing:

-}
-- semantic domain
type T_OptTyRep = ( )
-- cata
sem_OptTyRep :: (OptTyRep) ->
                (T_OptTyRep)
sem_OptTyRep ((Prelude.Just (x))) =
    (sem_OptTyRep_Just ((sem_TyRep (x))))
sem_OptTyRep (Prelude.Nothing) =
    sem_OptTyRep_Nothing
data Inh_OptTyRep = Inh_OptTyRep {}
data Syn_OptTyRep = Syn_OptTyRep {}
wrap_OptTyRep :: (T_OptTyRep) ->
                 (Inh_OptTyRep) ->
                 (Syn_OptTyRep)
wrap_OptTyRep (sem) ((Inh_OptTyRep )) =
    let 
    in  (Syn_OptTyRep )
sem_OptTyRep_Just :: (T_TyRep) ->
                     (T_OptTyRep)
sem_OptTyRep_Just (just_) =
    let 
    in  ( )
sem_OptTyRep_Nothing :: (T_OptTyRep)
sem_OptTyRep_Nothing  =
    let 
    in  ( )
-- OptTypeExpr -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : (Maybe Doc)

-}
{-
   local variables for OptTypeExpr.Just:

-}
{-
   local variables for OptTypeExpr.Nothing:

-}
-- semantic domain
type T_OptTypeExpr = ( ((Maybe Doc)))
-- cata
sem_OptTypeExpr :: (OptTypeExpr) ->
                   (T_OptTypeExpr)
sem_OptTypeExpr ((Prelude.Just (x))) =
    (sem_OptTypeExpr_Just ((sem_TypeExpr (x))))
sem_OptTypeExpr (Prelude.Nothing) =
    sem_OptTypeExpr_Nothing
data Inh_OptTypeExpr = Inh_OptTypeExpr {}
data Syn_OptTypeExpr = Syn_OptTypeExpr {pp_Syn_OptTypeExpr :: (Maybe Doc)}
wrap_OptTypeExpr :: (T_OptTypeExpr) ->
                    (Inh_OptTypeExpr) ->
                    (Syn_OptTypeExpr)
wrap_OptTypeExpr (sem) ((Inh_OptTypeExpr )) =
    let ( s1) =
            (sem )
    in  (Syn_OptTypeExpr (s1))
sem_OptTypeExpr_Just :: (T_TypeExpr) ->
                        (T_OptTypeExpr)
sem_OptTypeExpr_Just (just_) =
    let _lhsOpp :: ((Maybe Doc))
        _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
        -- "OutputOCamlExpr.ag"(line 132, column 21)
        (_lhsOpp@_) =
            Just _justIpp
    in  ( _lhsOpp)
sem_OptTypeExpr_Nothing :: (T_OptTypeExpr)
sem_OptTypeExpr_Nothing  =
    let _lhsOpp :: ((Maybe Doc))
        -- "OutputOCamlExpr.ag"(line 133, column 21)
        (_lhsOpp@_) =
            Nothing
    in  ( _lhsOpp)
-- Parameter ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Parameter.ParamPat:

-}
-- semantic domain
type T_Parameter = ( (Doc))
-- cata
sem_Parameter :: (Parameter) ->
                 (T_Parameter)
sem_Parameter ((ParamPat (_pat))) =
    (sem_Parameter_ParamPat ((sem_Pattern (_pat))))
data Inh_Parameter = Inh_Parameter {}
data Syn_Parameter = Syn_Parameter {pp_Syn_Parameter :: Doc}
wrap_Parameter :: (T_Parameter) ->
                  (Inh_Parameter) ->
                  (Syn_Parameter)
wrap_Parameter (sem) ((Inh_Parameter )) =
    let ( s1) =
            (sem )
    in  (Syn_Parameter (s1))
sem_Parameter_ParamPat :: (T_Pattern) ->
                          (T_Parameter)
sem_Parameter_ParamPat (pat_) =
    let _lhsOpp :: (Doc)
        _patIpp :: (Doc)
        ( _patIpp) =
            (pat_ )
        -- "OutputOCamlExpr.ag"(line 142, column 21)
        (_lhsOpp@_) =
            _patIpp
    in  ( _lhsOpp)
-- Parameters --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Parameters.Cons:

-}
{-
   local variables for Parameters.Nil:

-}
-- semantic domain
type T_Parameters = ( ([Doc]))
-- cata
sem_Parameters :: (Parameters) ->
                  (T_Parameters)
sem_Parameters (list) =
    (Prelude.foldr (sem_Parameters_Cons) (sem_Parameters_Nil) ((Prelude.map sem_Parameter list)))
data Inh_Parameters = Inh_Parameters {}
data Syn_Parameters = Syn_Parameters {pp_Syn_Parameters :: [Doc]}
wrap_Parameters :: (T_Parameters) ->
                   (Inh_Parameters) ->
                   (Syn_Parameters)
wrap_Parameters (sem) ((Inh_Parameters )) =
    let ( s1) =
            (sem )
    in  (Syn_Parameters (s1))
sem_Parameters_Cons :: (T_Parameter) ->
                       (T_Parameters) ->
                       (T_Parameters)
sem_Parameters_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Parameters_Nil :: (T_Parameters)
sem_Parameters_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Pattern -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Pattern.AnonPat:

-}
{-
   local variables for Pattern.ConstantPat:

-}
{-
   local variables for Pattern.ConstrPat:

-}
{-
   local variables for Pattern.ParenPat:

-}
{-
   local variables for Pattern.TuplePat:

-}
{-
   local variables for Pattern.ValuePat:

-}
-- semantic domain
type T_Pattern = ( (Doc))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((AnonPat )) =
    (sem_Pattern_AnonPat )
sem_Pattern ((ConstantPat (_constant))) =
    (sem_Pattern_ConstantPat ((sem_Constant (_constant))))
sem_Pattern ((ConstrPat (_constr) (_pat))) =
    (sem_Pattern_ConstrPat ((sem_Constr (_constr))) ((sem_Pattern (_pat))))
sem_Pattern ((ParenPat (_pat) (_opt_ty_expr))) =
    (sem_Pattern_ParenPat ((sem_Pattern (_pat))) ((sem_OptTypeExpr (_opt_ty_expr))))
sem_Pattern ((TuplePat (_pats))) =
    (sem_Pattern_TuplePat ((sem_Patterns (_pats))))
sem_Pattern ((ValuePat (_name))) =
    (sem_Pattern_ValuePat (_name))
data Inh_Pattern = Inh_Pattern {}
data Syn_Pattern = Syn_Pattern {pp_Syn_Pattern :: Doc}
wrap_Pattern :: (T_Pattern) ->
                (Inh_Pattern) ->
                (Syn_Pattern)
wrap_Pattern (sem) ((Inh_Pattern )) =
    let ( s1) =
            (sem )
    in  (Syn_Pattern (s1))
sem_Pattern_AnonPat :: (T_Pattern)
sem_Pattern_AnonPat  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 115, column 21)
        (_lhsOpp@_) =
            char '_'
    in  ( _lhsOpp)
sem_Pattern_ConstantPat :: (T_Constant) ->
                           (T_Pattern)
sem_Pattern_ConstantPat (constant_) =
    let _lhsOpp :: (Doc)
        _constantIpp :: (Doc)
        ( _constantIpp) =
            (constant_ )
        -- "OutputOCamlExpr.ag"(line 116, column 21)
        (_lhsOpp@_) =
            _constantIpp
    in  ( _lhsOpp)
sem_Pattern_ConstrPat :: (T_Constr) ->
                         (T_Pattern) ->
                         (T_Pattern)
sem_Pattern_ConstrPat (constr_) (pat_) =
    let _lhsOpp :: (Doc)
        _constrIpp :: (Doc)
        _patIpp :: (Doc)
        ( _constrIpp) =
            (constr_ )
        ( _patIpp) =
            (pat_ )
        -- "OutputOCamlExpr.ag"(line 118, column 21)
        (_lhsOpp@_) =
            _constrIpp <+> _patIpp
    in  ( _lhsOpp)
sem_Pattern_ParenPat :: (T_Pattern) ->
                        (T_OptTypeExpr) ->
                        (T_Pattern)
sem_Pattern_ParenPat (pat_) (opt_ty_expr_) =
    let _lhsOpp :: (Doc)
        _patIpp :: (Doc)
        _opt_ty_exprIpp :: ((Maybe Doc))
        ( _patIpp) =
            (pat_ )
        ( _opt_ty_exprIpp) =
            (opt_ty_expr_ )
        -- "OutputOCamlExpr.ag"(line 117, column 21)
        (_lhsOpp@_) =
            parens $ _patIpp <> optColon _opt_ty_exprIpp
    in  ( _lhsOpp)
sem_Pattern_TuplePat :: (T_Patterns) ->
                        (T_Pattern)
sem_Pattern_TuplePat (pats_) =
    let _lhsOpp :: (Doc)
        _patsIpp :: ([Doc])
        ( _patsIpp) =
            (pats_ )
        -- "OutputOCamlExpr.ag"(line 119, column 21)
        (_lhsOpp@_) =
            encloseSepAlt empty empty (text ",") _patsIpp
    in  ( _lhsOpp)
sem_Pattern_ValuePat :: (String) ->
                        (T_Pattern)
sem_Pattern_ValuePat (name_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 114, column 21)
        (_lhsOpp@_) =
            text name_
    in  ( _lhsOpp)
-- PatternClause -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for PatternClause.Tuple:

-}
-- semantic domain
type T_PatternClause = ( (Doc))
-- cata
sem_PatternClause :: (PatternClause) ->
                     (T_PatternClause)
sem_PatternClause (( pat,opt_guard,expr)) =
    (sem_PatternClause_Tuple ((sem_Pattern (pat))) ((sem_OptExpr (opt_guard))) ((sem_Expr (expr))))
data Inh_PatternClause = Inh_PatternClause {}
data Syn_PatternClause = Syn_PatternClause {pp_Syn_PatternClause :: Doc}
wrap_PatternClause :: (T_PatternClause) ->
                      (Inh_PatternClause) ->
                      (Syn_PatternClause)
wrap_PatternClause (sem) ((Inh_PatternClause )) =
    let ( s1) =
            (sem )
    in  (Syn_PatternClause (s1))
sem_PatternClause_Tuple :: (T_Pattern) ->
                           (T_OptExpr) ->
                           (T_Expr) ->
                           (T_PatternClause)
sem_PatternClause_Tuple (pat_) (opt_guard_) (expr_) =
    let _lhsOpp :: (Doc)
        _patIpp :: (Doc)
        _opt_guardIpp :: ((Maybe Doc))
        _exprIpp :: (Doc)
        ( _patIpp) =
            (pat_ )
        ( _opt_guardIpp) =
            (opt_guard_ )
        ( _exprIpp) =
            (expr_ )
        -- "OutputOCamlExpr.ag"(line 137, column 21)
        (_lhsOpp@_) =
            _patIpp <> optWhen _opt_guardIpp
              <+> text "->" <+> _exprIpp
    in  ( _lhsOpp)
-- PatternMatching ---------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for PatternMatching.Cons:

-}
{-
   local variables for PatternMatching.Nil:

-}
-- semantic domain
type T_PatternMatching = ( ([Doc]))
-- cata
sem_PatternMatching :: (PatternMatching) ->
                       (T_PatternMatching)
sem_PatternMatching (list) =
    (Prelude.foldr (sem_PatternMatching_Cons) (sem_PatternMatching_Nil) ((Prelude.map sem_PatternClause list)))
data Inh_PatternMatching = Inh_PatternMatching {}
data Syn_PatternMatching = Syn_PatternMatching {pp_Syn_PatternMatching :: [Doc]}
wrap_PatternMatching :: (T_PatternMatching) ->
                        (Inh_PatternMatching) ->
                        (Syn_PatternMatching)
wrap_PatternMatching (sem) ((Inh_PatternMatching )) =
    let ( s1) =
            (sem )
    in  (Syn_PatternMatching (s1))
sem_PatternMatching_Cons :: (T_PatternClause) ->
                            (T_PatternMatching) ->
                            (T_PatternMatching)
sem_PatternMatching_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_PatternMatching_Nil :: (T_PatternMatching)
sem_PatternMatching_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Patterns ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = ( ([Doc]))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (Prelude.foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((Prelude.map sem_Pattern list)))
data Inh_Patterns = Inh_Patterns {}
data Syn_Patterns = Syn_Patterns {pp_Syn_Patterns :: [Doc]}
wrap_Patterns :: (T_Patterns) ->
                 (Inh_Patterns) ->
                 (Syn_Patterns)
wrap_Patterns (sem) ((Inh_Patterns )) =
    let ( s1) =
            (sem )
    in  (Syn_Patterns (s1))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Program -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Program.Program:

-}
-- semantic domain
type T_Program = ( (Doc))
-- cata
sem_Program :: (Program) ->
               (T_Program)
sem_Program ((Program (_defs))) =
    (sem_Program_Program ((sem_Defs (_defs))))
data Inh_Program = Inh_Program {}
data Syn_Program = Syn_Program {pp_Syn_Program :: Doc}
wrap_Program :: (T_Program) ->
                (Inh_Program) ->
                (Syn_Program)
wrap_Program (sem) ((Inh_Program )) =
    let ( s1) =
            (sem )
    in  (Syn_Program (s1))
sem_Program_Program :: (T_Defs) ->
                       (T_Program)
sem_Program_Program (defs_) =
    let _lhsOpp :: (Doc)
        _defsIpp :: ([Doc])
        ( _defsIpp) =
            (defs_ )
        -- "OutputOCamlExpr.ag"(line 33, column 21)
        (_lhsOpp@_) =
            vsep $ _defsIpp
    in  ( _lhsOpp)
-- TyInfo ------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for TyInfo.Tuple:

-}
-- semantic domain
type T_TyInfo = ( )
-- cata
sem_TyInfo :: (TyInfo) ->
              (T_TyInfo)
sem_TyInfo (( opt_ty_equation,opt_ty_rep)) =
    (sem_TyInfo_Tuple ((sem_OptTyEquation (opt_ty_equation))) ((sem_OptTyRep (opt_ty_rep))))
data Inh_TyInfo = Inh_TyInfo {}
data Syn_TyInfo = Syn_TyInfo {}
wrap_TyInfo :: (T_TyInfo) ->
               (Inh_TyInfo) ->
               (Syn_TyInfo)
wrap_TyInfo (sem) ((Inh_TyInfo )) =
    let 
    in  (Syn_TyInfo )
sem_TyInfo_Tuple :: (T_OptTyEquation) ->
                    (T_OptTyRep) ->
                    (T_TyInfo)
sem_TyInfo_Tuple (opt_ty_equation_) (opt_ty_rep_) =
    let 
    in  ( )
-- TyParams ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for TyParams.Cons:

-}
{-
   local variables for TyParams.Nil:

-}
-- semantic domain
type T_TyParams = ( )
-- cata
sem_TyParams :: (TyParams) ->
                (T_TyParams)
sem_TyParams (list) =
    (Prelude.foldr (sem_TyParams_Cons) (sem_TyParams_Nil) (list))
data Inh_TyParams = Inh_TyParams {}
data Syn_TyParams = Syn_TyParams {}
wrap_TyParams :: (T_TyParams) ->
                 (Inh_TyParams) ->
                 (Syn_TyParams)
wrap_TyParams (sem) ((Inh_TyParams )) =
    let 
    in  (Syn_TyParams )
sem_TyParams_Cons :: (String) ->
                     (T_TyParams) ->
                     (T_TyParams)
sem_TyParams_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_TyParams_Nil :: (T_TyParams)
sem_TyParams_Nil  =
    let 
    in  ( )
-- TyRep -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for TyRep.ConstrRep:

-}
{-
   local variables for TyRep.RecordRep:

-}
-- semantic domain
type T_TyRep = ( )
-- cata
sem_TyRep :: (TyRep) ->
             (T_TyRep)
sem_TyRep ((ConstrRep (_constr_decls))) =
    (sem_TyRep_ConstrRep ((sem_ConstrDecls (_constr_decls))))
sem_TyRep ((RecordRep (_field_decls))) =
    (sem_TyRep_RecordRep ((sem_FieldDecls (_field_decls))))
data Inh_TyRep = Inh_TyRep {}
data Syn_TyRep = Syn_TyRep {}
wrap_TyRep :: (T_TyRep) ->
              (Inh_TyRep) ->
              (Syn_TyRep)
wrap_TyRep (sem) ((Inh_TyRep )) =
    let 
    in  (Syn_TyRep )
sem_TyRep_ConstrRep :: (T_ConstrDecls) ->
                       (T_TyRep)
sem_TyRep_ConstrRep (constr_decls_) =
    let 
    in  ( )
sem_TyRep_RecordRep :: (T_FieldDecls) ->
                       (T_TyRep)
sem_TyRep_RecordRep (field_decls_) =
    let 
    in  ( )
-- TypeDefinition ----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for TypeDefinition.TypeDefinition:

-}
-- semantic domain
type T_TypeDefinition = ( )
-- cata
sem_TypeDefinition :: (TypeDefinition) ->
                      (T_TypeDefinition)
sem_TypeDefinition ((TypeDefinition (_defs))) =
    (sem_TypeDefinition_TypeDefinition ((sem_Typedefs (_defs))))
data Inh_TypeDefinition = Inh_TypeDefinition {}
data Syn_TypeDefinition = Syn_TypeDefinition {}
wrap_TypeDefinition :: (T_TypeDefinition) ->
                       (Inh_TypeDefinition) ->
                       (Syn_TypeDefinition)
wrap_TypeDefinition (sem) ((Inh_TypeDefinition )) =
    let 
    in  (Syn_TypeDefinition )
sem_TypeDefinition_TypeDefinition :: (T_Typedefs) ->
                                     (T_TypeDefinition)
sem_TypeDefinition_TypeDefinition (defs_) =
    let 
    in  ( )
-- TypeExpr ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TypeExpr.TyExprAnon:

-}
{-
   local variables for TypeExpr.TyExprConstr:

-}
{-
   local variables for TypeExpr.TyExprConstrApp:

-}
{-
   local variables for TypeExpr.TyExprTuple:

-}
{-
   local variables for TypeExpr.TyExprVar:

-}
-- semantic domain
type T_TypeExpr = ( (Doc))
-- cata
sem_TypeExpr :: (TypeExpr) ->
                (T_TypeExpr)
sem_TypeExpr ((TyExprAnon )) =
    (sem_TypeExpr_TyExprAnon )
sem_TypeExpr ((TyExprConstr (_constr_name))) =
    (sem_TypeExpr_TyExprConstr (_constr_name))
sem_TypeExpr ((TyExprConstrApp (_ty_expr) (_ty_constr))) =
    (sem_TypeExpr_TyExprConstrApp ((sem_TypeExpr (_ty_expr))) ((sem_TypeExpr (_ty_constr))))
sem_TypeExpr ((TyExprTuple (_ty_exprs))) =
    (sem_TypeExpr_TyExprTuple ((sem_TypeExprs (_ty_exprs))))
sem_TypeExpr ((TyExprVar (_label))) =
    (sem_TypeExpr_TyExprVar (_label))
data Inh_TypeExpr = Inh_TypeExpr {}
data Syn_TypeExpr = Syn_TypeExpr {pp_Syn_TypeExpr :: Doc}
wrap_TypeExpr :: (T_TypeExpr) ->
                 (Inh_TypeExpr) ->
                 (Syn_TypeExpr)
wrap_TypeExpr (sem) ((Inh_TypeExpr )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeExpr (s1))
sem_TypeExpr_TyExprAnon :: (T_TypeExpr)
sem_TypeExpr_TyExprAnon  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 123, column 21)
        (_lhsOpp@_) =
            char '_'
    in  ( _lhsOpp)
sem_TypeExpr_TyExprConstr :: (String) ->
                             (T_TypeExpr)
sem_TypeExpr_TyExprConstr (constr_name_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 124, column 21)
        (_lhsOpp@_) =
            text constr_name_
    in  ( _lhsOpp)
sem_TypeExpr_TyExprConstrApp :: (T_TypeExpr) ->
                                (T_TypeExpr) ->
                                (T_TypeExpr)
sem_TypeExpr_TyExprConstrApp (ty_expr_) (ty_constr_) =
    let _lhsOpp :: (Doc)
        _ty_exprIpp :: (Doc)
        _ty_constrIpp :: (Doc)
        ( _ty_exprIpp) =
            (ty_expr_ )
        ( _ty_constrIpp) =
            (ty_constr_ )
        -- "OutputOCamlExpr.ag"(line 125, column 21)
        (_lhsOpp@_) =
            _ty_exprIpp <+> _ty_constrIpp
    in  ( _lhsOpp)
sem_TypeExpr_TyExprTuple :: (T_TypeExprs) ->
                            (T_TypeExpr)
sem_TypeExpr_TyExprTuple (ty_exprs_) =
    let _lhsOpp :: (Doc)
        _ty_exprsIpp :: ([Doc])
        ( _ty_exprsIpp) =
            (ty_exprs_ )
        -- "OutputOCamlExpr.ag"(line 126, column 21)
        (_lhsOpp@_) =
            starSep _ty_exprsIpp
    in  ( _lhsOpp)
sem_TypeExpr_TyExprVar :: (String) ->
                          (T_TypeExpr)
sem_TypeExpr_TyExprVar (label_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlExpr.ag"(line 122, column 21)
        (_lhsOpp@_) =
            text label_
    in  ( _lhsOpp)
-- TypeExprs ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for TypeExprs.Cons:

-}
{-
   local variables for TypeExprs.Nil:

-}
-- semantic domain
type T_TypeExprs = ( ([Doc]))
-- cata
sem_TypeExprs :: (TypeExprs) ->
                 (T_TypeExprs)
sem_TypeExprs (list) =
    (Prelude.foldr (sem_TypeExprs_Cons) (sem_TypeExprs_Nil) ((Prelude.map sem_TypeExpr list)))
data Inh_TypeExprs = Inh_TypeExprs {}
data Syn_TypeExprs = Syn_TypeExprs {pp_Syn_TypeExprs :: [Doc]}
wrap_TypeExprs :: (T_TypeExprs) ->
                  (Inh_TypeExprs) ->
                  (Syn_TypeExprs)
wrap_TypeExprs (sem) ((Inh_TypeExprs )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeExprs (s1))
sem_TypeExprs_Cons :: (T_TypeExpr) ->
                      (T_TypeExprs) ->
                      (T_TypeExprs)
sem_TypeExprs_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_TypeExprs_Nil :: (T_TypeExprs)
sem_TypeExprs_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Typedef -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Typedef.Tuple:

-}
-- semantic domain
type T_Typedef = ( )
-- cata
sem_Typedef :: (Typedef) ->
               (T_Typedef)
sem_Typedef (( ty_params,tycon_name,ty_info)) =
    (sem_Typedef_Tuple ((sem_TyParams (ty_params))) (tycon_name) ((sem_TyInfo (ty_info))))
data Inh_Typedef = Inh_Typedef {}
data Syn_Typedef = Syn_Typedef {}
wrap_Typedef :: (T_Typedef) ->
                (Inh_Typedef) ->
                (Syn_Typedef)
wrap_Typedef (sem) ((Inh_Typedef )) =
    let 
    in  (Syn_Typedef )
sem_Typedef_Tuple :: (T_TyParams) ->
                     (String) ->
                     (T_TyInfo) ->
                     (T_Typedef)
sem_Typedef_Tuple (ty_params_) (tycon_name_) (ty_info_) =
    let 
    in  ( )
-- Typedefs ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Typedefs.Cons:

-}
{-
   local variables for Typedefs.Nil:

-}
-- semantic domain
type T_Typedefs = ( )
-- cata
sem_Typedefs :: (Typedefs) ->
                (T_Typedefs)
sem_Typedefs (list) =
    (Prelude.foldr (sem_Typedefs_Cons) (sem_Typedefs_Nil) ((Prelude.map sem_Typedef list)))
data Inh_Typedefs = Inh_Typedefs {}
data Syn_Typedefs = Syn_Typedefs {}
wrap_Typedefs :: (T_Typedefs) ->
                 (Inh_Typedefs) ->
                 (Syn_Typedefs)
wrap_Typedefs (sem) ((Inh_Typedefs )) =
    let 
    in  (Syn_Typedefs )
sem_Typedefs_Cons :: (T_Typedef) ->
                     (T_Typedefs) ->
                     (T_Typedefs)
sem_Typedefs_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Typedefs_Nil :: (T_Typedefs)
sem_Typedefs_Nil  =
    let 
    in  ( )
-- ValueName ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for ValueName.IdVal:

-}
{-
   local variables for ValueName.OpVal:

-}
-- semantic domain
type T_ValueName = ( )
-- cata
sem_ValueName :: (ValueName) ->
                 (T_ValueName)
sem_ValueName ((IdVal (_value_name))) =
    (sem_ValueName_IdVal (_value_name))
sem_ValueName ((OpVal (_op_name))) =
    (sem_ValueName_OpVal (_op_name))
data Inh_ValueName = Inh_ValueName {}
data Syn_ValueName = Syn_ValueName {}
wrap_ValueName :: (T_ValueName) ->
                  (Inh_ValueName) ->
                  (Syn_ValueName)
wrap_ValueName (sem) ((Inh_ValueName )) =
    let 
    in  (Syn_ValueName )
sem_ValueName_IdVal :: (String) ->
                       (T_ValueName)
sem_ValueName_IdVal (value_name_) =
    let 
    in  ( )
sem_ValueName_OpVal :: (String) ->
                       (T_ValueName)
sem_ValueName_OpVal (op_name_) =
    let 
    in  ( )
-- ValuePath ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for ValuePath.Tuple:

-}
-- semantic domain
type T_ValuePath = ( (Doc))
-- cata
sem_ValuePath :: (ValuePath) ->
                 (T_ValuePath)
sem_ValuePath (( module_path,value_name)) =
    (sem_ValuePath_Tuple ((sem_OptIdentifier (module_path))) (value_name))
data Inh_ValuePath = Inh_ValuePath {}
data Syn_ValuePath = Syn_ValuePath {pp_Syn_ValuePath :: Doc}
wrap_ValuePath :: (T_ValuePath) ->
                  (Inh_ValuePath) ->
                  (Syn_ValuePath)
wrap_ValuePath (sem) ((Inh_ValuePath )) =
    let ( s1) =
            (sem )
    in  (Syn_ValuePath (s1))
sem_ValuePath_Tuple :: (T_OptIdentifier) ->
                       (String) ->
                       (T_ValuePath)
sem_ValuePath_Tuple (module_path_) (value_name_) =
    let _lhsOpp :: (Doc)
        _module_pathIidentity :: (OptIdentifier)
        ( _module_pathIidentity) =
            (module_path_ )
        -- "OutputOCamlExpr.ag"(line 97, column 21)
        (_lhsOpp@_) =
            prefix _module_pathIidentity <> text value_name_
    in  ( _lhsOpp)


