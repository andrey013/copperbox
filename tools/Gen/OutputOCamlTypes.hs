-- do not edit; automatically generated by UU.AG

module Gen.OutputOCamlTypes
  ( outputOCamlTypes
  ) where

import Base.PrimitiveTypes

import Gen.OCamlAbsSyn

import Util.PPExt

import PPrint




-- not quite the same as tupled0
parens2 :: [Doc] -> Doc
parens2 []  = empty
parens2 [a] = a <> space
parens2 as  = tupled as <> space



outputOCamlTypes :: [TypeDefinition] -> Doc
outputOCamlTypes xs = vsep $ map outputOCamlTypes' xs

outputOCamlTypes' decl = pp_Syn_TypeDefinition synthesized
  where synthesized = wrap_TypeDefinition (sem_TypeDefinition decl) inherited
        inherited   = Inh_TypeDefinition

          
-- Argument ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Argument.ArgExpr:

-}
-- semantic domain
type T_Argument = ( )
-- cata
sem_Argument :: (Argument) ->
                (T_Argument)
sem_Argument ((ArgExpr (_expr))) =
    (sem_Argument_ArgExpr ((sem_Expr (_expr))))
data Inh_Argument = Inh_Argument {}
data Syn_Argument = Syn_Argument {}
wrap_Argument :: (T_Argument) ->
                 (Inh_Argument) ->
                 (Syn_Argument)
wrap_Argument (sem) ((Inh_Argument )) =
    let 
    in  (Syn_Argument )
sem_Argument_ArgExpr :: (T_Expr) ->
                        (T_Argument)
sem_Argument_ArgExpr (expr_) =
    let 
    in  ( )
-- Arguments ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Arguments.Cons:

-}
{-
   local variables for Arguments.Nil:

-}
-- semantic domain
type T_Arguments = ( )
-- cata
sem_Arguments :: (Arguments) ->
                 (T_Arguments)
sem_Arguments (list) =
    (Prelude.foldr (sem_Arguments_Cons) (sem_Arguments_Nil) ((Prelude.map sem_Argument list)))
data Inh_Arguments = Inh_Arguments {}
data Syn_Arguments = Syn_Arguments {}
wrap_Arguments :: (T_Arguments) ->
                  (Inh_Arguments) ->
                  (Syn_Arguments)
wrap_Arguments (sem) ((Inh_Arguments )) =
    let 
    in  (Syn_Arguments )
sem_Arguments_Cons :: (T_Argument) ->
                      (T_Arguments) ->
                      (T_Arguments)
sem_Arguments_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Arguments_Nil :: (T_Arguments)
sem_Arguments_Nil  =
    let 
    in  ( )
-- Constant ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Constant.FloatLiteral:

-}
{-
   local variables for Constant.IntegerLiteral:

-}
{-
   local variables for Constant.Nil:

-}
{-
   local variables for Constant.StringLiteral:

-}
{-
   local variables for Constant.Unit:

-}
{-
   local variables for Constant.Val_False:

-}
{-
   local variables for Constant.Val_True:

-}
-- semantic domain
type T_Constant = ( )
-- cata
sem_Constant :: (Constant) ->
                (T_Constant)
sem_Constant ((FloatLiteral (_value))) =
    (sem_Constant_FloatLiteral (_value))
sem_Constant ((IntegerLiteral (_value))) =
    (sem_Constant_IntegerLiteral (_value))
sem_Constant ((Nil )) =
    (sem_Constant_Nil )
sem_Constant ((StringLiteral (_value))) =
    (sem_Constant_StringLiteral (_value))
sem_Constant ((Unit )) =
    (sem_Constant_Unit )
sem_Constant ((Val_False )) =
    (sem_Constant_Val_False )
sem_Constant ((Val_True )) =
    (sem_Constant_Val_True )
data Inh_Constant = Inh_Constant {}
data Syn_Constant = Syn_Constant {}
wrap_Constant :: (T_Constant) ->
                 (Inh_Constant) ->
                 (Syn_Constant)
wrap_Constant (sem) ((Inh_Constant )) =
    let 
    in  (Syn_Constant )
sem_Constant_FloatLiteral :: (Float) ->
                             (T_Constant)
sem_Constant_FloatLiteral (value_) =
    let 
    in  ( )
sem_Constant_IntegerLiteral :: (Int) ->
                               (T_Constant)
sem_Constant_IntegerLiteral (value_) =
    let 
    in  ( )
sem_Constant_Nil :: (T_Constant)
sem_Constant_Nil  =
    let 
    in  ( )
sem_Constant_StringLiteral :: (String) ->
                              (T_Constant)
sem_Constant_StringLiteral (value_) =
    let 
    in  ( )
sem_Constant_Unit :: (T_Constant)
sem_Constant_Unit  =
    let 
    in  ( )
sem_Constant_Val_False :: (T_Constant)
sem_Constant_Val_False  =
    let 
    in  ( )
sem_Constant_Val_True :: (T_Constant)
sem_Constant_Val_True  =
    let 
    in  ( )
-- Constr ------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Constr.Tuple:

-}
-- semantic domain
type T_Constr = ( )
-- cata
sem_Constr :: (Constr) ->
              (T_Constr)
sem_Constr (( module_path,constr_name)) =
    (sem_Constr_Tuple ((sem_OptIdentifier (module_path))) (constr_name))
data Inh_Constr = Inh_Constr {}
data Syn_Constr = Syn_Constr {}
wrap_Constr :: (T_Constr) ->
               (Inh_Constr) ->
               (Syn_Constr)
wrap_Constr (sem) ((Inh_Constr )) =
    let 
    in  (Syn_Constr )
sem_Constr_Tuple :: (T_OptIdentifier) ->
                    (String) ->
                    (T_Constr)
sem_Constr_Tuple (module_path_) (constr_name_) =
    let 
    in  ( )
-- ConstrDecl --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for ConstrDecl.Tuple:

-}
-- semantic domain
type T_ConstrDecl = ( (Doc))
-- cata
sem_ConstrDecl :: (ConstrDecl) ->
                  (T_ConstrDecl)
sem_ConstrDecl (( constr_name,opt_type_expr)) =
    (sem_ConstrDecl_Tuple (constr_name) ((sem_OptTypeExpr (opt_type_expr))))
data Inh_ConstrDecl = Inh_ConstrDecl {}
data Syn_ConstrDecl = Syn_ConstrDecl {pp_Syn_ConstrDecl :: Doc}
wrap_ConstrDecl :: (T_ConstrDecl) ->
                   (Inh_ConstrDecl) ->
                   (Syn_ConstrDecl)
wrap_ConstrDecl (sem) ((Inh_ConstrDecl )) =
    let ( s1) =
            (sem )
    in  (Syn_ConstrDecl (s1))
sem_ConstrDecl_Tuple :: (String) ->
                        (T_OptTypeExpr) ->
                        (T_ConstrDecl)
sem_ConstrDecl_Tuple (constr_name_) (opt_type_expr_) =
    let _lhsOpp :: (Doc)
        _opt_type_exprIpp_cdecl :: (Doc)
        ( _opt_type_exprIpp_cdecl) =
            (opt_type_expr_ )
        -- "OutputOCamlTypes.ag"(line 110, column 7)
        (_lhsOpp@_) =
            text constr_name_ <> _opt_type_exprIpp_cdecl
    in  ( _lhsOpp)
-- ConstrDecls -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for ConstrDecls.Cons:

-}
{-
   local variables for ConstrDecls.Nil:

-}
-- semantic domain
type T_ConstrDecls = ( ([Doc]))
-- cata
sem_ConstrDecls :: (ConstrDecls) ->
                   (T_ConstrDecls)
sem_ConstrDecls (list) =
    (Prelude.foldr (sem_ConstrDecls_Cons) (sem_ConstrDecls_Nil) ((Prelude.map sem_ConstrDecl list)))
data Inh_ConstrDecls = Inh_ConstrDecls {}
data Syn_ConstrDecls = Syn_ConstrDecls {pp_Syn_ConstrDecls :: [Doc]}
wrap_ConstrDecls :: (T_ConstrDecls) ->
                    (Inh_ConstrDecls) ->
                    (Syn_ConstrDecls)
wrap_ConstrDecls (sem) ((Inh_ConstrDecls )) =
    let ( s1) =
            (sem )
    in  (Syn_ConstrDecls (s1))
sem_ConstrDecls_Cons :: (T_ConstrDecl) ->
                        (T_ConstrDecls) ->
                        (T_ConstrDecls)
sem_ConstrDecls_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_ConstrDecls_Nil :: (T_ConstrDecls)
sem_ConstrDecls_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Def ---------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Def.MLet:

-}
{-
   local variables for Def.MLetrec:

-}
-- semantic domain
type T_Def = ( )
-- cata
sem_Def :: (Def) ->
           (T_Def)
sem_Def ((MLet (_binds))) =
    (sem_Def_MLet ((sem_LetBindings (_binds))))
sem_Def ((MLetrec (_binds))) =
    (sem_Def_MLetrec ((sem_LetBindings (_binds))))
data Inh_Def = Inh_Def {}
data Syn_Def = Syn_Def {}
wrap_Def :: (T_Def) ->
            (Inh_Def) ->
            (Syn_Def)
wrap_Def (sem) ((Inh_Def )) =
    let 
    in  (Syn_Def )
sem_Def_MLet :: (T_LetBindings) ->
                (T_Def)
sem_Def_MLet (binds_) =
    let 
    in  ( )
sem_Def_MLetrec :: (T_LetBindings) ->
                   (T_Def)
sem_Def_MLetrec (binds_) =
    let 
    in  ( )
-- Defs --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Defs.Cons:

-}
{-
   local variables for Defs.Nil:

-}
-- semantic domain
type T_Defs = ( )
-- cata
sem_Defs :: (Defs) ->
            (T_Defs)
sem_Defs (list) =
    (Prelude.foldr (sem_Defs_Cons) (sem_Defs_Nil) ((Prelude.map sem_Def list)))
data Inh_Defs = Inh_Defs {}
data Syn_Defs = Syn_Defs {}
wrap_Defs :: (T_Defs) ->
             (Inh_Defs) ->
             (Syn_Defs)
wrap_Defs (sem) ((Inh_Defs )) =
    let 
    in  (Syn_Defs )
sem_Defs_Cons :: (T_Def) ->
                 (T_Defs) ->
                 (T_Defs)
sem_Defs_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Defs_Nil :: (T_Defs)
sem_Defs_Nil  =
    let 
    in  ( )
-- Expr --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Expr.App:

-}
{-
   local variables for Expr.ConstantExpr:

-}
{-
   local variables for Expr.ConstrApp:

-}
{-
   local variables for Expr.FieldAccess:

-}
{-
   local variables for Expr.IfExpr:

-}
{-
   local variables for Expr.Let:

-}
{-
   local variables for Expr.Letrec:

-}
{-
   local variables for Expr.ListExpr:

-}
{-
   local variables for Expr.Match:

-}
{-
   local variables for Expr.ParenExpr:

-}
{-
   local variables for Expr.Seq:

-}
{-
   local variables for Expr.TupleExpr:

-}
{-
   local variables for Expr.ValuePathExpr:

-}
-- semantic domain
type T_Expr = ( )
-- cata
sem_Expr :: (Expr) ->
            (T_Expr)
sem_Expr ((App (_expr) (_args))) =
    (sem_Expr_App ((sem_Expr (_expr))) ((sem_Arguments (_args))))
sem_Expr ((ConstantExpr (_value))) =
    (sem_Expr_ConstantExpr ((sem_Constant (_value))))
sem_Expr ((ConstrApp (_constr) (_expr))) =
    (sem_Expr_ConstrApp ((sem_Constr (_constr))) ((sem_Expr (_expr))))
sem_Expr ((FieldAccess (_expr) (_field))) =
    (sem_Expr_FieldAccess ((sem_Expr (_expr))) ((sem_Field (_field))))
sem_Expr ((IfExpr (_cond_expr) (_then_expr) (_opt_else))) =
    (sem_Expr_IfExpr ((sem_Expr (_cond_expr))) ((sem_Expr (_then_expr))) ((sem_OptExpr (_opt_else))))
sem_Expr ((Let (_binds) (_expr))) =
    (sem_Expr_Let ((sem_LetBindings (_binds))) ((sem_Expr (_expr))))
sem_Expr ((Letrec (_binds) (_expr))) =
    (sem_Expr_Letrec ((sem_LetBindings (_binds))) ((sem_Expr (_expr))))
sem_Expr ((ListExpr (_exprs))) =
    (sem_Expr_ListExpr ((sem_Exprs (_exprs))))
sem_Expr ((Match (_expr) (_pat_match))) =
    (sem_Expr_Match ((sem_Expr (_expr))) ((sem_PatternMatching (_pat_match))))
sem_Expr ((ParenExpr (_expr))) =
    (sem_Expr_ParenExpr ((sem_Expr (_expr))))
sem_Expr ((Seq (_expr1) (_expr2))) =
    (sem_Expr_Seq ((sem_Expr (_expr1))) ((sem_Expr (_expr2))))
sem_Expr ((TupleExpr (_exprs))) =
    (sem_Expr_TupleExpr ((sem_Exprs (_exprs))))
sem_Expr ((ValuePathExpr (_value_path))) =
    (sem_Expr_ValuePathExpr ((sem_ValuePath (_value_path))))
data Inh_Expr = Inh_Expr {}
data Syn_Expr = Syn_Expr {}
wrap_Expr :: (T_Expr) ->
             (Inh_Expr) ->
             (Syn_Expr)
wrap_Expr (sem) ((Inh_Expr )) =
    let 
    in  (Syn_Expr )
sem_Expr_App :: (T_Expr) ->
                (T_Arguments) ->
                (T_Expr)
sem_Expr_App (expr_) (args_) =
    let 
    in  ( )
sem_Expr_ConstantExpr :: (T_Constant) ->
                         (T_Expr)
sem_Expr_ConstantExpr (value_) =
    let 
    in  ( )
sem_Expr_ConstrApp :: (T_Constr) ->
                      (T_Expr) ->
                      (T_Expr)
sem_Expr_ConstrApp (constr_) (expr_) =
    let 
    in  ( )
sem_Expr_FieldAccess :: (T_Expr) ->
                        (T_Field) ->
                        (T_Expr)
sem_Expr_FieldAccess (expr_) (field_) =
    let 
    in  ( )
sem_Expr_IfExpr :: (T_Expr) ->
                   (T_Expr) ->
                   (T_OptExpr) ->
                   (T_Expr)
sem_Expr_IfExpr (cond_expr_) (then_expr_) (opt_else_) =
    let 
    in  ( )
sem_Expr_Let :: (T_LetBindings) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Let (binds_) (expr_) =
    let 
    in  ( )
sem_Expr_Letrec :: (T_LetBindings) ->
                   (T_Expr) ->
                   (T_Expr)
sem_Expr_Letrec (binds_) (expr_) =
    let 
    in  ( )
sem_Expr_ListExpr :: (T_Exprs) ->
                     (T_Expr)
sem_Expr_ListExpr (exprs_) =
    let 
    in  ( )
sem_Expr_Match :: (T_Expr) ->
                  (T_PatternMatching) ->
                  (T_Expr)
sem_Expr_Match (expr_) (pat_match_) =
    let 
    in  ( )
sem_Expr_ParenExpr :: (T_Expr) ->
                      (T_Expr)
sem_Expr_ParenExpr (expr_) =
    let 
    in  ( )
sem_Expr_Seq :: (T_Expr) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Seq (expr1_) (expr2_) =
    let 
    in  ( )
sem_Expr_TupleExpr :: (T_Exprs) ->
                      (T_Expr)
sem_Expr_TupleExpr (exprs_) =
    let 
    in  ( )
sem_Expr_ValuePathExpr :: (T_ValuePath) ->
                          (T_Expr)
sem_Expr_ValuePathExpr (value_path_) =
    let 
    in  ( )
-- Exprs -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Exprs.Cons:

-}
{-
   local variables for Exprs.Nil:

-}
-- semantic domain
type T_Exprs = ( )
-- cata
sem_Exprs :: (Exprs) ->
             (T_Exprs)
sem_Exprs (list) =
    (Prelude.foldr (sem_Exprs_Cons) (sem_Exprs_Nil) ((Prelude.map sem_Expr list)))
data Inh_Exprs = Inh_Exprs {}
data Syn_Exprs = Syn_Exprs {}
wrap_Exprs :: (T_Exprs) ->
              (Inh_Exprs) ->
              (Syn_Exprs)
wrap_Exprs (sem) ((Inh_Exprs )) =
    let 
    in  (Syn_Exprs )
sem_Exprs_Cons :: (T_Expr) ->
                  (T_Exprs) ->
                  (T_Exprs)
sem_Exprs_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Exprs_Nil :: (T_Exprs)
sem_Exprs_Nil  =
    let 
    in  ( )
-- Field -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Field.Tuple:

-}
-- semantic domain
type T_Field = ( )
-- cata
sem_Field :: (Field) ->
             (T_Field)
sem_Field (( module_path,field_name)) =
    (sem_Field_Tuple ((sem_OptIdentifier (module_path))) (field_name))
data Inh_Field = Inh_Field {}
data Syn_Field = Syn_Field {}
wrap_Field :: (T_Field) ->
              (Inh_Field) ->
              (Syn_Field)
wrap_Field (sem) ((Inh_Field )) =
    let 
    in  (Syn_Field )
sem_Field_Tuple :: (T_OptIdentifier) ->
                   (String) ->
                   (T_Field)
sem_Field_Tuple (module_path_) (field_name_) =
    let 
    in  ( )
-- FieldDecl ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for FieldDecl.Tuple:

-}
-- semantic domain
type T_FieldDecl = ( (Doc))
-- cata
sem_FieldDecl :: (FieldDecl) ->
                 (T_FieldDecl)
sem_FieldDecl (( field_name,ty_expr)) =
    (sem_FieldDecl_Tuple (field_name) ((sem_TypeExpr (ty_expr))))
data Inh_FieldDecl = Inh_FieldDecl {}
data Syn_FieldDecl = Syn_FieldDecl {pp_Syn_FieldDecl :: Doc}
wrap_FieldDecl :: (T_FieldDecl) ->
                  (Inh_FieldDecl) ->
                  (Syn_FieldDecl)
wrap_FieldDecl (sem) ((Inh_FieldDecl )) =
    let ( s1) =
            (sem )
    in  (Syn_FieldDecl (s1))
sem_FieldDecl_Tuple :: (String) ->
                       (T_TypeExpr) ->
                       (T_FieldDecl)
sem_FieldDecl_Tuple (field_name_) (ty_expr_) =
    let _lhsOpp :: (Doc)
        _ty_exprIpp :: (Doc)
        ( _ty_exprIpp) =
            (ty_expr_ )
        -- "OutputOCamlTypes.ag"(line 115, column 7)
        (_lhsOpp@_) =
            fill 12 (text field_name_) <+> colon <+> _ty_exprIpp
    in  ( _lhsOpp)
-- FieldDecls --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for FieldDecls.Cons:

-}
{-
   local variables for FieldDecls.Nil:

-}
-- semantic domain
type T_FieldDecls = ( ([Doc]))
-- cata
sem_FieldDecls :: (FieldDecls) ->
                  (T_FieldDecls)
sem_FieldDecls (list) =
    (Prelude.foldr (sem_FieldDecls_Cons) (sem_FieldDecls_Nil) ((Prelude.map sem_FieldDecl list)))
data Inh_FieldDecls = Inh_FieldDecls {}
data Syn_FieldDecls = Syn_FieldDecls {pp_Syn_FieldDecls :: [Doc]}
wrap_FieldDecls :: (T_FieldDecls) ->
                   (Inh_FieldDecls) ->
                   (Syn_FieldDecls)
wrap_FieldDecls (sem) ((Inh_FieldDecls )) =
    let ( s1) =
            (sem )
    in  (Syn_FieldDecls (s1))
sem_FieldDecls_Cons :: (T_FieldDecl) ->
                       (T_FieldDecls) ->
                       (T_FieldDecls)
sem_FieldDecls_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_FieldDecls_Nil :: (T_FieldDecls)
sem_FieldDecls_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- LetBinding --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for LetBinding.PatternBinding:

-}
{-
   local variables for LetBinding.ValueBinding:

-}
-- semantic domain
type T_LetBinding = ( )
-- cata
sem_LetBinding :: (LetBinding) ->
                  (T_LetBinding)
sem_LetBinding ((PatternBinding (_pat) (_expr))) =
    (sem_LetBinding_PatternBinding ((sem_Pattern (_pat))) ((sem_Expr (_expr))))
sem_LetBinding ((ValueBinding (_val_name) (_params) (_opt_ty) (_expr))) =
    (sem_LetBinding_ValueBinding (_val_name) ((sem_Parameters (_params))) ((sem_OptTypeExpr (_opt_ty))) ((sem_Expr (_expr))))
data Inh_LetBinding = Inh_LetBinding {}
data Syn_LetBinding = Syn_LetBinding {}
wrap_LetBinding :: (T_LetBinding) ->
                   (Inh_LetBinding) ->
                   (Syn_LetBinding)
wrap_LetBinding (sem) ((Inh_LetBinding )) =
    let 
    in  (Syn_LetBinding )
sem_LetBinding_PatternBinding :: (T_Pattern) ->
                                 (T_Expr) ->
                                 (T_LetBinding)
sem_LetBinding_PatternBinding (pat_) (expr_) =
    let 
    in  ( )
sem_LetBinding_ValueBinding :: (String) ->
                               (T_Parameters) ->
                               (T_OptTypeExpr) ->
                               (T_Expr) ->
                               (T_LetBinding)
sem_LetBinding_ValueBinding (val_name_) (params_) (opt_ty_) (expr_) =
    let _opt_tyIpp_cdecl :: (Doc)
        ( _opt_tyIpp_cdecl) =
            (opt_ty_ )
    in  ( )
-- LetBindings -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for LetBindings.Cons:

-}
{-
   local variables for LetBindings.Nil:

-}
-- semantic domain
type T_LetBindings = ( )
-- cata
sem_LetBindings :: (LetBindings) ->
                   (T_LetBindings)
sem_LetBindings (list) =
    (Prelude.foldr (sem_LetBindings_Cons) (sem_LetBindings_Nil) ((Prelude.map sem_LetBinding list)))
data Inh_LetBindings = Inh_LetBindings {}
data Syn_LetBindings = Syn_LetBindings {}
wrap_LetBindings :: (T_LetBindings) ->
                    (Inh_LetBindings) ->
                    (Syn_LetBindings)
wrap_LetBindings (sem) ((Inh_LetBindings )) =
    let 
    in  (Syn_LetBindings )
sem_LetBindings_Cons :: (T_LetBinding) ->
                        (T_LetBindings) ->
                        (T_LetBindings)
sem_LetBindings_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_LetBindings_Nil :: (T_LetBindings)
sem_LetBindings_Nil  =
    let 
    in  ( )
-- OptExpr -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptExpr.Just:

-}
{-
   local variables for OptExpr.Nothing:

-}
-- semantic domain
type T_OptExpr = ( )
-- cata
sem_OptExpr :: (OptExpr) ->
               (T_OptExpr)
sem_OptExpr ((Prelude.Just (x))) =
    (sem_OptExpr_Just ((sem_Expr (x))))
sem_OptExpr (Prelude.Nothing) =
    sem_OptExpr_Nothing
data Inh_OptExpr = Inh_OptExpr {}
data Syn_OptExpr = Syn_OptExpr {}
wrap_OptExpr :: (T_OptExpr) ->
                (Inh_OptExpr) ->
                (Syn_OptExpr)
wrap_OptExpr (sem) ((Inh_OptExpr )) =
    let 
    in  (Syn_OptExpr )
sem_OptExpr_Just :: (T_Expr) ->
                    (T_OptExpr)
sem_OptExpr_Just (just_) =
    let 
    in  ( )
sem_OptExpr_Nothing :: (T_OptExpr)
sem_OptExpr_Nothing  =
    let 
    in  ( )
-- OptIdentifier -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptIdentifier.Tuple:

-}
-- semantic domain
type T_OptIdentifier = ( )
-- cata
sem_OptIdentifier :: (OptIdentifier) ->
                     (T_OptIdentifier)
sem_OptIdentifier (( name)) =
    (sem_OptIdentifier_Tuple (name))
data Inh_OptIdentifier = Inh_OptIdentifier {}
data Syn_OptIdentifier = Syn_OptIdentifier {}
wrap_OptIdentifier :: (T_OptIdentifier) ->
                      (Inh_OptIdentifier) ->
                      (Syn_OptIdentifier)
wrap_OptIdentifier (sem) ((Inh_OptIdentifier )) =
    let 
    in  (Syn_OptIdentifier )
sem_OptIdentifier_Tuple :: ((Maybe String)) ->
                           (T_OptIdentifier)
sem_OptIdentifier_Tuple (name_) =
    let 
    in  ( )
-- OptTyEquation -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for OptTyEquation.Just:

-}
{-
   local variables for OptTyEquation.Nothing:

-}
-- semantic domain
type T_OptTyEquation = ( (Doc))
-- cata
sem_OptTyEquation :: (OptTyEquation) ->
                     (T_OptTyEquation)
sem_OptTyEquation ((Prelude.Just (x))) =
    (sem_OptTyEquation_Just ((sem_TypeExpr (x))))
sem_OptTyEquation (Prelude.Nothing) =
    sem_OptTyEquation_Nothing
data Inh_OptTyEquation = Inh_OptTyEquation {}
data Syn_OptTyEquation = Syn_OptTyEquation {pp_Syn_OptTyEquation :: Doc}
wrap_OptTyEquation :: (T_OptTyEquation) ->
                      (Inh_OptTyEquation) ->
                      (Syn_OptTyEquation)
wrap_OptTyEquation (sem) ((Inh_OptTyEquation )) =
    let ( s1) =
            (sem )
    in  (Syn_OptTyEquation (s1))
sem_OptTyEquation_Just :: (T_TypeExpr) ->
                          (T_OptTyEquation)
sem_OptTyEquation_Just (just_) =
    let _lhsOpp :: (Doc)
        _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
        -- "OutputOCamlTypes.ag"(line 63, column 7)
        (_lhsOpp@_) =
            space <> equals <+> _justIpp <> space
    in  ( _lhsOpp)
sem_OptTyEquation_Nothing :: (T_OptTyEquation)
sem_OptTyEquation_Nothing  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlTypes.ag"(line 65, column 7)
        (_lhsOpp@_) =
            empty
    in  ( _lhsOpp)
-- OptTyRep ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for OptTyRep.Just:

-}
{-
   local variables for OptTyRep.Nothing:

-}
-- semantic domain
type T_OptTyRep = ( (Doc))
-- cata
sem_OptTyRep :: (OptTyRep) ->
                (T_OptTyRep)
sem_OptTyRep ((Prelude.Just (x))) =
    (sem_OptTyRep_Just ((sem_TyRep (x))))
sem_OptTyRep (Prelude.Nothing) =
    sem_OptTyRep_Nothing
data Inh_OptTyRep = Inh_OptTyRep {}
data Syn_OptTyRep = Syn_OptTyRep {pp_Syn_OptTyRep :: Doc}
wrap_OptTyRep :: (T_OptTyRep) ->
                 (Inh_OptTyRep) ->
                 (Syn_OptTyRep)
wrap_OptTyRep (sem) ((Inh_OptTyRep )) =
    let ( s1) =
            (sem )
    in  (Syn_OptTyRep (s1))
sem_OptTyRep_Just :: (T_TyRep) ->
                     (T_OptTyRep)
sem_OptTyRep_Just (just_) =
    let _lhsOpp :: (Doc)
        _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
        -- "OutputOCamlTypes.ag"(line 69, column 7)
        (_lhsOpp@_) =
            space <> equals <+> _justIpp <> space
    in  ( _lhsOpp)
sem_OptTyRep_Nothing :: (T_OptTyRep)
sem_OptTyRep_Nothing  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlTypes.ag"(line 71, column 7)
        (_lhsOpp@_) =
            empty
    in  ( _lhsOpp)
-- OptTypeExpr -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp_cdecl             : Doc

-}
{-
   local variables for OptTypeExpr.Just:

-}
{-
   local variables for OptTypeExpr.Nothing:

-}
-- semantic domain
type T_OptTypeExpr = ( (Doc))
-- cata
sem_OptTypeExpr :: (OptTypeExpr) ->
                   (T_OptTypeExpr)
sem_OptTypeExpr ((Prelude.Just (x))) =
    (sem_OptTypeExpr_Just ((sem_TypeExpr (x))))
sem_OptTypeExpr (Prelude.Nothing) =
    sem_OptTypeExpr_Nothing
data Inh_OptTypeExpr = Inh_OptTypeExpr {}
data Syn_OptTypeExpr = Syn_OptTypeExpr {pp_cdecl_Syn_OptTypeExpr :: Doc}
wrap_OptTypeExpr :: (T_OptTypeExpr) ->
                    (Inh_OptTypeExpr) ->
                    (Syn_OptTypeExpr)
wrap_OptTypeExpr (sem) ((Inh_OptTypeExpr )) =
    let ( s1) =
            (sem )
    in  (Syn_OptTypeExpr (s1))
sem_OptTypeExpr_Just :: (T_TypeExpr) ->
                        (T_OptTypeExpr)
sem_OptTypeExpr_Just (just_) =
    let _lhsOpp_cdecl :: (Doc)
        _justIpp :: (Doc)
        ( _justIpp) =
            (just_ )
        -- "OutputOCamlTypes.ag"(line 104, column 7)
        (_lhsOpp_cdecl@_) =
            space <> text "of" <+> _justIpp
    in  ( _lhsOpp_cdecl)
sem_OptTypeExpr_Nothing :: (T_OptTypeExpr)
sem_OptTypeExpr_Nothing  =
    let _lhsOpp_cdecl :: (Doc)
        -- "OutputOCamlTypes.ag"(line 106, column 7)
        (_lhsOpp_cdecl@_) =
            empty
    in  ( _lhsOpp_cdecl)
-- Parameter ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Parameter.ParamPat:

-}
-- semantic domain
type T_Parameter = ( )
-- cata
sem_Parameter :: (Parameter) ->
                 (T_Parameter)
sem_Parameter ((ParamPat (_pat))) =
    (sem_Parameter_ParamPat ((sem_Pattern (_pat))))
data Inh_Parameter = Inh_Parameter {}
data Syn_Parameter = Syn_Parameter {}
wrap_Parameter :: (T_Parameter) ->
                  (Inh_Parameter) ->
                  (Syn_Parameter)
wrap_Parameter (sem) ((Inh_Parameter )) =
    let 
    in  (Syn_Parameter )
sem_Parameter_ParamPat :: (T_Pattern) ->
                          (T_Parameter)
sem_Parameter_ParamPat (pat_) =
    let 
    in  ( )
-- Parameters --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Parameters.Cons:

-}
{-
   local variables for Parameters.Nil:

-}
-- semantic domain
type T_Parameters = ( )
-- cata
sem_Parameters :: (Parameters) ->
                  (T_Parameters)
sem_Parameters (list) =
    (Prelude.foldr (sem_Parameters_Cons) (sem_Parameters_Nil) ((Prelude.map sem_Parameter list)))
data Inh_Parameters = Inh_Parameters {}
data Syn_Parameters = Syn_Parameters {}
wrap_Parameters :: (T_Parameters) ->
                   (Inh_Parameters) ->
                   (Syn_Parameters)
wrap_Parameters (sem) ((Inh_Parameters )) =
    let 
    in  (Syn_Parameters )
sem_Parameters_Cons :: (T_Parameter) ->
                       (T_Parameters) ->
                       (T_Parameters)
sem_Parameters_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Parameters_Nil :: (T_Parameters)
sem_Parameters_Nil  =
    let 
    in  ( )
-- Pattern -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Pattern.AnonPat:

-}
{-
   local variables for Pattern.ConstantPat:

-}
{-
   local variables for Pattern.ConstrPat:

-}
{-
   local variables for Pattern.ParenPat:

-}
{-
   local variables for Pattern.TuplePat:

-}
{-
   local variables for Pattern.ValuePat:

-}
-- semantic domain
type T_Pattern = ( )
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((AnonPat )) =
    (sem_Pattern_AnonPat )
sem_Pattern ((ConstantPat (_constant))) =
    (sem_Pattern_ConstantPat ((sem_Constant (_constant))))
sem_Pattern ((ConstrPat (_constr) (_pat))) =
    (sem_Pattern_ConstrPat ((sem_Constr (_constr))) ((sem_Pattern (_pat))))
sem_Pattern ((ParenPat (_pat) (_opt_ty_expr))) =
    (sem_Pattern_ParenPat ((sem_Pattern (_pat))) ((sem_OptTypeExpr (_opt_ty_expr))))
sem_Pattern ((TuplePat (_pats))) =
    (sem_Pattern_TuplePat ((sem_Patterns (_pats))))
sem_Pattern ((ValuePat (_name))) =
    (sem_Pattern_ValuePat (_name))
data Inh_Pattern = Inh_Pattern {}
data Syn_Pattern = Syn_Pattern {}
wrap_Pattern :: (T_Pattern) ->
                (Inh_Pattern) ->
                (Syn_Pattern)
wrap_Pattern (sem) ((Inh_Pattern )) =
    let 
    in  (Syn_Pattern )
sem_Pattern_AnonPat :: (T_Pattern)
sem_Pattern_AnonPat  =
    let 
    in  ( )
sem_Pattern_ConstantPat :: (T_Constant) ->
                           (T_Pattern)
sem_Pattern_ConstantPat (constant_) =
    let 
    in  ( )
sem_Pattern_ConstrPat :: (T_Constr) ->
                         (T_Pattern) ->
                         (T_Pattern)
sem_Pattern_ConstrPat (constr_) (pat_) =
    let 
    in  ( )
sem_Pattern_ParenPat :: (T_Pattern) ->
                        (T_OptTypeExpr) ->
                        (T_Pattern)
sem_Pattern_ParenPat (pat_) (opt_ty_expr_) =
    let _opt_ty_exprIpp_cdecl :: (Doc)
        ( _opt_ty_exprIpp_cdecl) =
            (opt_ty_expr_ )
    in  ( )
sem_Pattern_TuplePat :: (T_Patterns) ->
                        (T_Pattern)
sem_Pattern_TuplePat (pats_) =
    let 
    in  ( )
sem_Pattern_ValuePat :: (String) ->
                        (T_Pattern)
sem_Pattern_ValuePat (name_) =
    let 
    in  ( )
-- PatternClause -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for PatternClause.Tuple:

-}
-- semantic domain
type T_PatternClause = ( )
-- cata
sem_PatternClause :: (PatternClause) ->
                     (T_PatternClause)
sem_PatternClause (( pat,opt_guard,expr)) =
    (sem_PatternClause_Tuple ((sem_Pattern (pat))) ((sem_OptExpr (opt_guard))) ((sem_Expr (expr))))
data Inh_PatternClause = Inh_PatternClause {}
data Syn_PatternClause = Syn_PatternClause {}
wrap_PatternClause :: (T_PatternClause) ->
                      (Inh_PatternClause) ->
                      (Syn_PatternClause)
wrap_PatternClause (sem) ((Inh_PatternClause )) =
    let 
    in  (Syn_PatternClause )
sem_PatternClause_Tuple :: (T_Pattern) ->
                           (T_OptExpr) ->
                           (T_Expr) ->
                           (T_PatternClause)
sem_PatternClause_Tuple (pat_) (opt_guard_) (expr_) =
    let 
    in  ( )
-- PatternMatching ---------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for PatternMatching.Cons:

-}
{-
   local variables for PatternMatching.Nil:

-}
-- semantic domain
type T_PatternMatching = ( )
-- cata
sem_PatternMatching :: (PatternMatching) ->
                       (T_PatternMatching)
sem_PatternMatching (list) =
    (Prelude.foldr (sem_PatternMatching_Cons) (sem_PatternMatching_Nil) ((Prelude.map sem_PatternClause list)))
data Inh_PatternMatching = Inh_PatternMatching {}
data Syn_PatternMatching = Syn_PatternMatching {}
wrap_PatternMatching :: (T_PatternMatching) ->
                        (Inh_PatternMatching) ->
                        (Syn_PatternMatching)
wrap_PatternMatching (sem) ((Inh_PatternMatching )) =
    let 
    in  (Syn_PatternMatching )
sem_PatternMatching_Cons :: (T_PatternClause) ->
                            (T_PatternMatching) ->
                            (T_PatternMatching)
sem_PatternMatching_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_PatternMatching_Nil :: (T_PatternMatching)
sem_PatternMatching_Nil  =
    let 
    in  ( )
-- Patterns ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = ( )
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (Prelude.foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((Prelude.map sem_Pattern list)))
data Inh_Patterns = Inh_Patterns {}
data Syn_Patterns = Syn_Patterns {}
wrap_Patterns :: (T_Patterns) ->
                 (Inh_Patterns) ->
                 (Syn_Patterns)
wrap_Patterns (sem) ((Inh_Patterns )) =
    let 
    in  (Syn_Patterns )
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (hd_) (tl_) =
    let 
    in  ( )
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil  =
    let 
    in  ( )
-- Program -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Program.Program:

-}
-- semantic domain
type T_Program = ( )
-- cata
sem_Program :: (Program) ->
               (T_Program)
sem_Program ((Program (_defs))) =
    (sem_Program_Program ((sem_Defs (_defs))))
data Inh_Program = Inh_Program {}
data Syn_Program = Syn_Program {}
wrap_Program :: (T_Program) ->
                (Inh_Program) ->
                (Syn_Program)
wrap_Program (sem) ((Inh_Program )) =
    let 
    in  (Syn_Program )
sem_Program_Program :: (T_Defs) ->
                       (T_Program)
sem_Program_Program (defs_) =
    let 
    in  ( )
-- TyInfo ------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TyInfo.Tuple:

-}
-- semantic domain
type T_TyInfo = ( (Doc))
-- cata
sem_TyInfo :: (TyInfo) ->
              (T_TyInfo)
sem_TyInfo (( opt_ty_equation,opt_ty_rep)) =
    (sem_TyInfo_Tuple ((sem_OptTyEquation (opt_ty_equation))) ((sem_OptTyRep (opt_ty_rep))))
data Inh_TyInfo = Inh_TyInfo {}
data Syn_TyInfo = Syn_TyInfo {pp_Syn_TyInfo :: Doc}
wrap_TyInfo :: (T_TyInfo) ->
               (Inh_TyInfo) ->
               (Syn_TyInfo)
wrap_TyInfo (sem) ((Inh_TyInfo )) =
    let ( s1) =
            (sem )
    in  (Syn_TyInfo (s1))
sem_TyInfo_Tuple :: (T_OptTyEquation) ->
                    (T_OptTyRep) ->
                    (T_TyInfo)
sem_TyInfo_Tuple (opt_ty_equation_) (opt_ty_rep_) =
    let _lhsOpp :: (Doc)
        _opt_ty_equationIpp :: (Doc)
        _opt_ty_repIpp :: (Doc)
        ( _opt_ty_equationIpp) =
            (opt_ty_equation_ )
        ( _opt_ty_repIpp) =
            (opt_ty_rep_ )
        -- "OutputOCamlTypes.ag"(line 49, column 7)
        (_lhsOpp@_) =
            _opt_ty_equationIpp <> opt_ty_rep_
    in  ( _lhsOpp)
-- TyParams ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      names                : [String]

-}
{-
   local variables for TyParams.Cons:

-}
{-
   local variables for TyParams.Nil:

-}
-- semantic domain
type T_TyParams = ( ([String]))
-- cata
sem_TyParams :: (TyParams) ->
                (T_TyParams)
sem_TyParams (list) =
    (Prelude.foldr (sem_TyParams_Cons) (sem_TyParams_Nil) (list))
data Inh_TyParams = Inh_TyParams {}
data Syn_TyParams = Syn_TyParams {names_Syn_TyParams :: [String]}
wrap_TyParams :: (T_TyParams) ->
                 (Inh_TyParams) ->
                 (Syn_TyParams)
wrap_TyParams (sem) ((Inh_TyParams )) =
    let ( s1) =
            (sem )
    in  (Syn_TyParams (s1))
sem_TyParams_Cons :: (String) ->
                     (T_TyParams) ->
                     (T_TyParams)
sem_TyParams_Cons (hd_) (tl_) =
    let _lhsOnames :: ([String])
        _tlInames :: ([String])
        ( _tlInames) =
            (tl_ )
        -- "OutputOCamlTypes.ag"(line 56, column 7)
        (_lhsOnames@_) =
            hd_ : _tlInames
    in  ( _lhsOnames)
sem_TyParams_Nil :: (T_TyParams)
sem_TyParams_Nil  =
    let _lhsOnames :: ([String])
        -- "OutputOCamlTypes.ag"(line 58, column 7)
        (_lhsOnames@_) =
            []
    in  ( _lhsOnames)
-- TyRep -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TyRep.ConstrRep:

-}
{-
   local variables for TyRep.RecordRep:

-}
-- semantic domain
type T_TyRep = ( (Doc))
-- cata
sem_TyRep :: (TyRep) ->
             (T_TyRep)
sem_TyRep ((ConstrRep (_constr_decls))) =
    (sem_TyRep_ConstrRep ((sem_ConstrDecls (_constr_decls))))
sem_TyRep ((RecordRep (_field_decls))) =
    (sem_TyRep_RecordRep ((sem_FieldDecls (_field_decls))))
data Inh_TyRep = Inh_TyRep {}
data Syn_TyRep = Syn_TyRep {pp_Syn_TyRep :: Doc}
wrap_TyRep :: (T_TyRep) ->
              (Inh_TyRep) ->
              (Syn_TyRep)
wrap_TyRep (sem) ((Inh_TyRep )) =
    let ( s1) =
            (sem )
    in  (Syn_TyRep (s1))
sem_TyRep_ConstrRep :: (T_ConstrDecls) ->
                       (T_TyRep)
sem_TyRep_ConstrRep (constr_decls_) =
    let _lhsOpp :: (Doc)
        _constr_declsIpp :: ([Doc])
        ( _constr_declsIpp) =
            (constr_decls_ )
        -- "OutputOCamlTypes.ag"(line 91, column 7)
        (_lhsOpp@_) =
            line <> indent 2 (encloseSepAlt (text "  ")
                                            empty
                                            (line <> text "| ")
                                            (_constr_declsIpp) )
    in  ( _lhsOpp)
sem_TyRep_RecordRep :: (T_FieldDecls) ->
                       (T_TyRep)
sem_TyRep_RecordRep (field_decls_) =
    let _lhsOpp :: (Doc)
        _field_declsIpp :: ([Doc])
        ( _field_declsIpp) =
            (field_decls_ )
        -- "OutputOCamlTypes.ag"(line 96, column 7)
        (_lhsOpp@_) =
            lbrace <> line
                   <> (indent 2 (vsep $ punctuate semi _field_declsIpp))
                   <> rbrace
    in  ( _lhsOpp)
-- TypeDefinition ----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TypeDefinition.TypeDefinition:

-}
-- semantic domain
type T_TypeDefinition = ( (Doc))
-- cata
sem_TypeDefinition :: (TypeDefinition) ->
                      (T_TypeDefinition)
sem_TypeDefinition ((TypeDefinition (_defs))) =
    (sem_TypeDefinition_TypeDefinition ((sem_Typedefs (_defs))))
data Inh_TypeDefinition = Inh_TypeDefinition {}
data Syn_TypeDefinition = Syn_TypeDefinition {pp_Syn_TypeDefinition :: Doc}
wrap_TypeDefinition :: (T_TypeDefinition) ->
                       (Inh_TypeDefinition) ->
                       (Syn_TypeDefinition)
wrap_TypeDefinition (sem) ((Inh_TypeDefinition )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeDefinition (s1))
sem_TypeDefinition_TypeDefinition :: (T_Typedefs) ->
                                     (T_TypeDefinition)
sem_TypeDefinition_TypeDefinition (defs_) =
    let _lhsOpp :: (Doc)
        _defsIpp :: ([Doc])
        ( _defsIpp) =
            (defs_ )
        -- "OutputOCamlTypes.ag"(line 36, column 7)
        (_lhsOpp@_) =
            encloseSepAlt (text "type ")
                          empty
                          (line <> text "and ")
                          _defsIpp
    in  ( _lhsOpp)
-- TypeExpr ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for TypeExpr.TyExprAnon:

-}
{-
   local variables for TypeExpr.TyExprConstr:

-}
{-
   local variables for TypeExpr.TyExprConstrApp:

-}
{-
   local variables for TypeExpr.TyExprTuple:

-}
{-
   local variables for TypeExpr.TyExprVar:

-}
-- semantic domain
type T_TypeExpr = ( (Doc))
-- cata
sem_TypeExpr :: (TypeExpr) ->
                (T_TypeExpr)
sem_TypeExpr ((TyExprAnon )) =
    (sem_TypeExpr_TyExprAnon )
sem_TypeExpr ((TyExprConstr (_constr_name))) =
    (sem_TypeExpr_TyExprConstr (_constr_name))
sem_TypeExpr ((TyExprConstrApp (_ty_expr) (_ty_constr))) =
    (sem_TypeExpr_TyExprConstrApp ((sem_TypeExpr (_ty_expr))) ((sem_TypeExpr (_ty_constr))))
sem_TypeExpr ((TyExprTuple (_ty_exprs))) =
    (sem_TypeExpr_TyExprTuple ((sem_TypeExprs (_ty_exprs))))
sem_TypeExpr ((TyExprVar (_label))) =
    (sem_TypeExpr_TyExprVar (_label))
data Inh_TypeExpr = Inh_TypeExpr {}
data Syn_TypeExpr = Syn_TypeExpr {pp_Syn_TypeExpr :: Doc}
wrap_TypeExpr :: (T_TypeExpr) ->
                 (Inh_TypeExpr) ->
                 (Syn_TypeExpr)
wrap_TypeExpr (sem) ((Inh_TypeExpr )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeExpr (s1))
sem_TypeExpr_TyExprAnon :: (T_TypeExpr)
sem_TypeExpr_TyExprAnon  =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlTypes.ag"(line 78, column 7)
        (_lhsOpp@_) =
            char '_'
    in  ( _lhsOpp)
sem_TypeExpr_TyExprConstr :: (String) ->
                             (T_TypeExpr)
sem_TypeExpr_TyExprConstr (constr_name_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlTypes.ag"(line 80, column 7)
        (_lhsOpp@_) =
            text constr_name_
    in  ( _lhsOpp)
sem_TypeExpr_TyExprConstrApp :: (T_TypeExpr) ->
                                (T_TypeExpr) ->
                                (T_TypeExpr)
sem_TypeExpr_TyExprConstrApp (ty_expr_) (ty_constr_) =
    let _lhsOpp :: (Doc)
        _ty_exprIpp :: (Doc)
        _ty_constrIpp :: (Doc)
        ( _ty_exprIpp) =
            (ty_expr_ )
        ( _ty_constrIpp) =
            (ty_constr_ )
        -- "OutputOCamlTypes.ag"(line 82, column 7)
        (_lhsOpp@_) =
            _ty_exprIpp <+> _ty_constrIpp
    in  ( _lhsOpp)
sem_TypeExpr_TyExprTuple :: (T_TypeExprs) ->
                            (T_TypeExpr)
sem_TypeExpr_TyExprTuple (ty_exprs_) =
    let _lhsOpp :: (Doc)
        _ty_exprsIpp :: ([Doc])
        ( _ty_exprsIpp) =
            (ty_exprs_ )
        -- "OutputOCamlTypes.ag"(line 84, column 7)
        (_lhsOpp@_) =
            starSep _ty_exprsIpp
    in  ( _lhsOpp)
sem_TypeExpr_TyExprVar :: (String) ->
                          (T_TypeExpr)
sem_TypeExpr_TyExprVar (label_) =
    let _lhsOpp :: (Doc)
        -- "OutputOCamlTypes.ag"(line 76, column 7)
        (_lhsOpp@_) =
            text label_
    in  ( _lhsOpp)
-- TypeExprs ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for TypeExprs.Cons:

-}
{-
   local variables for TypeExprs.Nil:

-}
-- semantic domain
type T_TypeExprs = ( ([Doc]))
-- cata
sem_TypeExprs :: (TypeExprs) ->
                 (T_TypeExprs)
sem_TypeExprs (list) =
    (Prelude.foldr (sem_TypeExprs_Cons) (sem_TypeExprs_Nil) ((Prelude.map sem_TypeExpr list)))
data Inh_TypeExprs = Inh_TypeExprs {}
data Syn_TypeExprs = Syn_TypeExprs {pp_Syn_TypeExprs :: [Doc]}
wrap_TypeExprs :: (T_TypeExprs) ->
                  (Inh_TypeExprs) ->
                  (Syn_TypeExprs)
wrap_TypeExprs (sem) ((Inh_TypeExprs )) =
    let ( s1) =
            (sem )
    in  (Syn_TypeExprs (s1))
sem_TypeExprs_Cons :: (T_TypeExpr) ->
                      (T_TypeExprs) ->
                      (T_TypeExprs)
sem_TypeExprs_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_TypeExprs_Nil :: (T_TypeExprs)
sem_TypeExprs_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- Typedef -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : Doc

-}
{-
   local variables for Typedef.Tuple:

-}
-- semantic domain
type T_Typedef = ( (Doc))
-- cata
sem_Typedef :: (Typedef) ->
               (T_Typedef)
sem_Typedef (( ty_params,tycon_name,ty_info)) =
    (sem_Typedef_Tuple ((sem_TyParams (ty_params))) (tycon_name) ((sem_TyInfo (ty_info))))
data Inh_Typedef = Inh_Typedef {}
data Syn_Typedef = Syn_Typedef {pp_Syn_Typedef :: Doc}
wrap_Typedef :: (T_Typedef) ->
                (Inh_Typedef) ->
                (Syn_Typedef)
wrap_Typedef (sem) ((Inh_Typedef )) =
    let ( s1) =
            (sem )
    in  (Syn_Typedef (s1))
sem_Typedef_Tuple :: (T_TyParams) ->
                     (String) ->
                     (T_TyInfo) ->
                     (T_Typedef)
sem_Typedef_Tuple (ty_params_) (tycon_name_) (ty_info_) =
    let _lhsOpp :: (Doc)
        _ty_paramsInames :: ([String])
        _ty_infoIpp :: (Doc)
        ( _ty_paramsInames) =
            (ty_params_ )
        ( _ty_infoIpp) =
            (ty_info_ )
        -- "OutputOCamlTypes.ag"(line 43, column 7)
        (_lhsOpp@_) =
            parens2 (map text _ty_paramsInames)
              <> text tycon_name_
              <> _ty_infoIpp
    in  ( _lhsOpp)
-- Typedefs ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pp                   : [Doc]

-}
{-
   local variables for Typedefs.Cons:

-}
{-
   local variables for Typedefs.Nil:

-}
-- semantic domain
type T_Typedefs = ( ([Doc]))
-- cata
sem_Typedefs :: (Typedefs) ->
                (T_Typedefs)
sem_Typedefs (list) =
    (Prelude.foldr (sem_Typedefs_Cons) (sem_Typedefs_Nil) ((Prelude.map sem_Typedef list)))
data Inh_Typedefs = Inh_Typedefs {}
data Syn_Typedefs = Syn_Typedefs {pp_Syn_Typedefs :: [Doc]}
wrap_Typedefs :: (T_Typedefs) ->
                 (Inh_Typedefs) ->
                 (Syn_Typedefs)
wrap_Typedefs (sem) ((Inh_Typedefs )) =
    let ( s1) =
            (sem )
    in  (Syn_Typedefs (s1))
sem_Typedefs_Cons :: (T_Typedef) ->
                     (T_Typedefs) ->
                     (T_Typedefs)
sem_Typedefs_Cons (hd_) (tl_) =
    let _lhsOpp :: ([Doc])
        _hdIpp :: (Doc)
        _tlIpp :: ([Doc])
        ( _hdIpp) =
            (hd_ )
        ( _tlIpp) =
            (tl_ )
        -- use rule
        (_lhsOpp@_) =
            _hdIpp : _tlIpp
    in  ( _lhsOpp)
sem_Typedefs_Nil :: (T_Typedefs)
sem_Typedefs_Nil  =
    let _lhsOpp :: ([Doc])
        -- use rule
        (_lhsOpp@_) =
            []
    in  ( _lhsOpp)
-- ValueName ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for ValueName.IdVal:

-}
{-
   local variables for ValueName.OpVal:

-}
-- semantic domain
type T_ValueName = ( )
-- cata
sem_ValueName :: (ValueName) ->
                 (T_ValueName)
sem_ValueName ((IdVal (_value_name))) =
    (sem_ValueName_IdVal (_value_name))
sem_ValueName ((OpVal (_op_name))) =
    (sem_ValueName_OpVal (_op_name))
data Inh_ValueName = Inh_ValueName {}
data Syn_ValueName = Syn_ValueName {}
wrap_ValueName :: (T_ValueName) ->
                  (Inh_ValueName) ->
                  (Syn_ValueName)
wrap_ValueName (sem) ((Inh_ValueName )) =
    let 
    in  (Syn_ValueName )
sem_ValueName_IdVal :: (String) ->
                       (T_ValueName)
sem_ValueName_IdVal (value_name_) =
    let 
    in  ( )
sem_ValueName_OpVal :: (String) ->
                       (T_ValueName)
sem_ValueName_OpVal (op_name_) =
    let 
    in  ( )
-- ValuePath ---------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for ValuePath.Tuple:

-}
-- semantic domain
type T_ValuePath = ( )
-- cata
sem_ValuePath :: (ValuePath) ->
                 (T_ValuePath)
sem_ValuePath (( module_path,value_name)) =
    (sem_ValuePath_Tuple ((sem_OptIdentifier (module_path))) (value_name))
data Inh_ValuePath = Inh_ValuePath {}
data Syn_ValuePath = Syn_ValuePath {}
wrap_ValuePath :: (T_ValuePath) ->
                  (Inh_ValuePath) ->
                  (Syn_ValuePath)
wrap_ValuePath (sem) ((Inh_ValuePath )) =
    let 
    in  (Syn_ValuePath )
sem_ValuePath_Tuple :: (T_OptIdentifier) ->
                       (String) ->
                       (T_ValuePath)
sem_ValuePath_Tuple (module_path_) (value_name_) =
    let 
    in  ( )


