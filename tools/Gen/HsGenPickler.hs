-- do not edit; automatically generated by UU.AG

module Gen.HsGenPickler
  ( makeHsPicklerCode
  ) where


import Base.Lib
import Ext.Haskell.HsSyntax
import Ext.Haskell.HsCodeFragments
import Ext.Haskell.CodeGen
import Util.Naming


import qualified Language.Haskell.Syntax as HS
  



uname :: String -> String 
uname "Bool"    = "ubool"
uname "Char"    = "uchar"
uname "Float"   = "ufloat"
uname "Int64"   = "uint64"
uname s         = "read" ++ s


pname :: String -> String
pname "Bool"    = "pbool" 
pname "Char"    = "pchar"
pname "Float"   = "pfloat"
pname "Int64"   = "pint64"
pname s         = "write" ++ s


makeHsPicklerCode :: AsdlSpec -> String -> HS.HsModule
makeHsPicklerCode defn name = runCode $ mkModule_Syn_AsdlSpec synthesized
  where synthesized = wrap_AsdlSpec (sem_AsdlSpec defn) inherited
        inherited   = Inh_AsdlSpec name




-- AsdlPrim ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      pickler_name         : String
      unpickler_name       : String

-}
{-
   local variables for AsdlPrim.TyExternalPrim:

-}
{-
   local variables for AsdlPrim.TyIdentifier:

-}
{-
   local variables for AsdlPrim.TyInt:

-}
{-
   local variables for AsdlPrim.TyRef:

-}
{-
   local variables for AsdlPrim.TyString:

-}
{-
   local variables for AsdlPrim.TyUnit:

-}
-- semantic domain
type T_AsdlPrim = ( (String),(String))
-- cata
sem_AsdlPrim :: (AsdlPrim) ->
                (T_AsdlPrim)
sem_AsdlPrim ((TyExternalPrim (_name))) =
    (sem_AsdlPrim_TyExternalPrim (_name))
sem_AsdlPrim ((TyIdentifier )) =
    (sem_AsdlPrim_TyIdentifier )
sem_AsdlPrim ((TyInt )) =
    (sem_AsdlPrim_TyInt )
sem_AsdlPrim ((TyRef (_name))) =
    (sem_AsdlPrim_TyRef (_name))
sem_AsdlPrim ((TyString )) =
    (sem_AsdlPrim_TyString )
sem_AsdlPrim ((TyUnit )) =
    (sem_AsdlPrim_TyUnit )
data Inh_AsdlPrim = Inh_AsdlPrim {}
data Syn_AsdlPrim = Syn_AsdlPrim {pickler_name_Syn_AsdlPrim :: String,unpickler_name_Syn_AsdlPrim :: String}
wrap_AsdlPrim :: (T_AsdlPrim) ->
                 (Inh_AsdlPrim) ->
                 (Syn_AsdlPrim)
wrap_AsdlPrim (sem) ((Inh_AsdlPrim )) =
    let ( s1,s2) =
            (sem )
    in  (Syn_AsdlPrim (s1) (s2))
sem_AsdlPrim_TyExternalPrim :: (String) ->
                               (T_AsdlPrim)
sem_AsdlPrim_TyExternalPrim (name_) =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 127, column 25)
        (_lhsOpickler_name@_) =
            pname $ haskellName name_
        -- "HsGenPickler.ag"(line 137, column 25)
        (_lhsOunpickler_name@_) =
            uname $ haskellName name_
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
sem_AsdlPrim_TyIdentifier :: (T_AsdlPrim)
sem_AsdlPrim_TyIdentifier  =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 125, column 25)
        (_lhsOpickler_name@_) =
            "pstring"
        -- "HsGenPickler.ag"(line 135, column 25)
        (_lhsOunpickler_name@_) =
            "ustring"
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
sem_AsdlPrim_TyInt :: (T_AsdlPrim)
sem_AsdlPrim_TyInt  =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 124, column 25)
        (_lhsOpickler_name@_) =
            "pint"
        -- "HsGenPickler.ag"(line 134, column 25)
        (_lhsOunpickler_name@_) =
            "uint"
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
sem_AsdlPrim_TyRef :: (String) ->
                      (T_AsdlPrim)
sem_AsdlPrim_TyRef (name_) =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 126, column 25)
        (_lhsOpickler_name@_) =
            pname $ haskellName name_
        -- "HsGenPickler.ag"(line 136, column 25)
        (_lhsOunpickler_name@_) =
            uname $ haskellName name_
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
sem_AsdlPrim_TyString :: (T_AsdlPrim)
sem_AsdlPrim_TyString  =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 123, column 25)
        (_lhsOpickler_name@_) =
            "pstring"
        -- "HsGenPickler.ag"(line 133, column 25)
        (_lhsOunpickler_name@_) =
            "ustring"
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
sem_AsdlPrim_TyUnit :: (T_AsdlPrim)
sem_AsdlPrim_TyUnit  =
    let _lhsOpickler_name :: (String)
        _lhsOunpickler_name :: (String)
        -- "HsGenPickler.ag"(line 122, column 25)
        (_lhsOpickler_name@_) =
            "punit"
        -- "HsGenPickler.ag"(line 132, column 25)
        (_lhsOunpickler_name@_) =
            "uunit"
    in  ( _lhsOpickler_name,_lhsOunpickler_name)
-- AsdlSpec ----------------------------------------------------
{-
   inherited attributes:
      base_name            : String

   chained attributes:

   synthesised attributes:
      mkModule             : ModuleS

-}
{-
   local variables for AsdlSpec.AsdlSpec:
      hs_mod_name

-}
-- semantic domain
type T_AsdlSpec = (String) ->
                  ( (ModuleS))
-- cata
sem_AsdlSpec :: (AsdlSpec) ->
                (T_AsdlSpec)
sem_AsdlSpec ((AsdlSpec (_decls))) =
    (sem_AsdlSpec_AsdlSpec ((sem_Decls (_decls))))
data Inh_AsdlSpec = Inh_AsdlSpec {base_name_Inh_AsdlSpec :: String}
data Syn_AsdlSpec = Syn_AsdlSpec {mkModule_Syn_AsdlSpec :: ModuleS}
wrap_AsdlSpec :: (T_AsdlSpec) ->
                 (Inh_AsdlSpec) ->
                 (Syn_AsdlSpec)
wrap_AsdlSpec (sem) ((Inh_AsdlSpec (i1))) =
    let ( s1) =
            (sem (i1))
    in  (Syn_AsdlSpec (s1))
sem_AsdlSpec_AsdlSpec :: (T_Decls) ->
                         (T_AsdlSpec)
sem_AsdlSpec_AsdlSpec (decls_) =
    \ _lhsIbase_name ->
        let _lhsOmkModule :: (ModuleS)
            _declsImkHsDecl :: ([DeclS])
            ( _declsImkHsDecl) =
                (decls_ )
            -- "HsGenPickler.ag"(line 36, column 7)
            (_hs_mod_name@_) =
                _lhsIbase_name ++ "Pkl"
            -- "HsGenPickler.ag"(line 29, column 7)
            (_lhsOmkModule@_) =
                moduleD (moduleN _hs_mod_name    )
                        []
                        [ importD (moduleN "AsdlBase") False Nothing Nothing
                        , importD (moduleN (_lhsIbase_name ++ "AbsSyn")) False Nothing Nothing
                        ]
                        _declsImkHsDecl
        in  ( _lhsOmkModule)
-- AsdlType ----------------------------------------------------
{-
   inherited attributes:
      defname              : String

   chained attributes:

   synthesised attributes:
      readD                : DeclS
      writeD               : [DeclS]

-}
{-
   local variables for AsdlType.Prod:

-}
{-
   local variables for AsdlType.Sum:

-}
-- semantic domain
type T_AsdlType = (String) ->
                  ( (DeclS),([DeclS]))
-- cata
sem_AsdlType :: (AsdlType) ->
                (T_AsdlType)
sem_AsdlType ((Prod (_fields))) =
    (sem_AsdlType_Prod ((sem_Fields (_fields))))
sem_AsdlType ((Sum (_constrs))) =
    (sem_AsdlType_Sum ((sem_Constrs (_constrs))))
data Inh_AsdlType = Inh_AsdlType {defname_Inh_AsdlType :: String}
data Syn_AsdlType = Syn_AsdlType {readD_Syn_AsdlType :: DeclS,writeD_Syn_AsdlType :: [DeclS]}
wrap_AsdlType :: (T_AsdlType) ->
                 (Inh_AsdlType) ->
                 (Syn_AsdlType)
wrap_AsdlType (sem) ((Inh_AsdlType (i1))) =
    let ( s1,s2) =
            (sem (i1))
    in  (Syn_AsdlType (s1) (s2))
sem_AsdlType_Prod :: (T_Fields) ->
                     (T_AsdlType)
sem_AsdlType_Prod (fields_) =
    \ _lhsIdefname ->
        let _lhsOreadD :: (DeclS)
            _lhsOwriteD :: ([DeclS])
            _fieldsIpicklr :: ([(String, Cardinality)])
            _fieldsIunpick :: ([(String, Cardinality)])
            ( _fieldsIpicklr,_fieldsIunpick) =
                (fields_ )
            -- "HsGenPickler.ag"(line 77, column 7)
            (_lhsOreadD@_) =
                tupleReadD _lhsIdefname _fieldsIunpick
            -- "HsGenPickler.ag"(line 76, column 7)
            (_lhsOwriteD@_) =
                [tuplePicklerD _lhsIdefname _fieldsIpicklr]
        in  ( _lhsOreadD,_lhsOwriteD)
sem_AsdlType_Sum :: (T_Constrs) ->
                    (T_AsdlType)
sem_AsdlType_Sum (constrs_) =
    \ _lhsIdefname ->
        let _lhsOreadD :: (DeclS)
            _lhsOwriteD :: ([DeclS])
            _constrsInumber :: (Int)
            _constrsIreadElt :: ([(String,[(String, Cardinality)])])
            _constrsIwriteD :: ([DeclS])
            _constrsOdefname :: (String)
            _constrsOnumber :: (Int)
            ( _constrsInumber,_constrsIreadElt,_constrsIwriteD) =
                (constrs_ (_constrsOdefname) (_constrsOnumber))
            -- "HsGenPickler.ag"(line 74, column 7)
            (_constrsOnumber@_) =
                1
            -- "HsGenPickler.ag"(line 73, column 7)
            (_lhsOreadD@_) =
                dtypeReadD _lhsIdefname _constrsIreadElt
            -- "HsGenPickler.ag"(line 72, column 7)
            (_lhsOwriteD@_) =
                _constrsIwriteD
            -- copy rule (down)
            (_constrsOdefname@_) =
                _lhsIdefname
        in  ( _lhsOreadD,_lhsOwriteD)
-- Cardinality -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      identity             : SELF

-}
{-
   local variables for Cardinality.One:
      identity

-}
{-
   local variables for Cardinality.Opt:
      identity

-}
{-
   local variables for Cardinality.Zom:
      identity

-}
-- semantic domain
type T_Cardinality = ( (Cardinality))
-- cata
sem_Cardinality :: (Cardinality) ->
                   (T_Cardinality)
sem_Cardinality ((One )) =
    (sem_Cardinality_One )
sem_Cardinality ((Opt )) =
    (sem_Cardinality_Opt )
sem_Cardinality ((Zom )) =
    (sem_Cardinality_Zom )
data Inh_Cardinality = Inh_Cardinality {}
data Syn_Cardinality = Syn_Cardinality {identity_Syn_Cardinality :: Cardinality}
wrap_Cardinality :: (T_Cardinality) ->
                    (Inh_Cardinality) ->
                    (Syn_Cardinality)
wrap_Cardinality (sem) ((Inh_Cardinality )) =
    let ( s1) =
            (sem )
    in  (Syn_Cardinality (s1))
sem_Cardinality_One :: (T_Cardinality)
sem_Cardinality_One  =
    let _lhsOidentity :: (Cardinality)
        -- self rule
        (_identity@_) =
            One
        -- self rule
        (_lhsOidentity@_) =
            _identity
    in  ( _lhsOidentity)
sem_Cardinality_Opt :: (T_Cardinality)
sem_Cardinality_Opt  =
    let _lhsOidentity :: (Cardinality)
        -- self rule
        (_identity@_) =
            Opt
        -- self rule
        (_lhsOidentity@_) =
            _identity
    in  ( _lhsOidentity)
sem_Cardinality_Zom :: (T_Cardinality)
sem_Cardinality_Zom  =
    let _lhsOidentity :: (Cardinality)
        -- self rule
        (_identity@_) =
            Zom
        -- self rule
        (_lhsOidentity@_) =
            _identity
    in  ( _lhsOidentity)
-- Constr ------------------------------------------------------
{-
   inherited attributes:
      defname              : String
      number               : Int

   chained attributes:

   synthesised attributes:
      readElt              : (String,[(String, Cardinality)])
      writeD               : DeclS

-}
{-
   local variables for Constr.Constr:

-}
-- semantic domain
type T_Constr = (String) ->
                (Int) ->
                ( ((String,[(String, Cardinality)])),(DeclS))
-- cata
sem_Constr :: (Constr) ->
              (T_Constr)
sem_Constr ((Constr (_label) (_fields))) =
    (sem_Constr_Constr (_label) ((sem_Fields (_fields))))
data Inh_Constr = Inh_Constr {defname_Inh_Constr :: String,number_Inh_Constr :: Int}
data Syn_Constr = Syn_Constr {readElt_Syn_Constr :: (String,[(String, Cardinality)]),writeD_Syn_Constr :: DeclS}
wrap_Constr :: (T_Constr) ->
               (Inh_Constr) ->
               (Syn_Constr)
wrap_Constr (sem) ((Inh_Constr (i1) (i2))) =
    let ( s1,s2) =
            (sem (i1) (i2))
    in  (Syn_Constr (s1) (s2))
sem_Constr_Constr :: (String) ->
                     (T_Fields) ->
                     (T_Constr)
sem_Constr_Constr (label_) (fields_) =
    \ _lhsIdefname
      _lhsInumber ->
        let _lhsOreadElt :: ((String,[(String, Cardinality)]))
            _lhsOwriteD :: (DeclS)
            _fieldsIpicklr :: ([(String, Cardinality)])
            _fieldsIunpick :: ([(String, Cardinality)])
            ( _fieldsIpicklr,_fieldsIunpick) =
                (fields_ )
            -- "HsGenPickler.ag"(line 97, column 7)
            (_lhsOwriteD@_) =
                constrPicklerD _lhsIdefname
                               label_
                               _lhsInumber
                               _fieldsIpicklr
            -- "HsGenPickler.ag"(line 106, column 7)
            (_lhsOreadElt@_) =
                (label_, _fieldsIunpick)
        in  ( _lhsOreadElt,_lhsOwriteD)
-- Constrs -----------------------------------------------------
{-
   inherited attributes:
      defname              : String

   chained attributes:
      number               : Int

   synthesised attributes:
      readElt              : [(String,[(String, Cardinality)])]
      writeD               : [DeclS]

-}
{-
   local variables for Constrs.Cons:

-}
{-
   local variables for Constrs.Nil:

-}
-- semantic domain
type T_Constrs = (String) ->
                 (Int) ->
                 ( (Int),([(String,[(String, Cardinality)])]),([DeclS]))
-- cata
sem_Constrs :: (Constrs) ->
               (T_Constrs)
sem_Constrs (list) =
    (Prelude.foldr (sem_Constrs_Cons) (sem_Constrs_Nil) ((Prelude.map sem_Constr list)))
data Inh_Constrs = Inh_Constrs {defname_Inh_Constrs :: String,number_Inh_Constrs :: Int}
data Syn_Constrs = Syn_Constrs {number_Syn_Constrs :: Int,readElt_Syn_Constrs :: [(String,[(String, Cardinality)])],writeD_Syn_Constrs :: [DeclS]}
wrap_Constrs :: (T_Constrs) ->
                (Inh_Constrs) ->
                (Syn_Constrs)
wrap_Constrs (sem) ((Inh_Constrs (i1) (i2))) =
    let ( s1,s2,s3) =
            (sem (i1) (i2))
    in  (Syn_Constrs (s1) (s2) (s3))
sem_Constrs_Cons :: (T_Constr) ->
                    (T_Constrs) ->
                    (T_Constrs)
sem_Constrs_Cons (hd_) (tl_) =
    \ _lhsIdefname
      _lhsInumber ->
        let _lhsOnumber :: (Int)
            _lhsOreadElt :: ([(String,[(String, Cardinality)])])
            _lhsOwriteD :: ([DeclS])
            _hdIreadElt :: ((String,[(String, Cardinality)]))
            _hdIwriteD :: (DeclS)
            _hdOdefname :: (String)
            _hdOnumber :: (Int)
            _tlInumber :: (Int)
            _tlIreadElt :: ([(String,[(String, Cardinality)])])
            _tlIwriteD :: ([DeclS])
            _tlOdefname :: (String)
            _tlOnumber :: (Int)
            ( _hdIreadElt,_hdIwriteD) =
                (hd_ (_hdOdefname) (_hdOnumber))
            ( _tlInumber,_tlIreadElt,_tlIwriteD) =
                (tl_ (_tlOdefname) (_tlOnumber))
            -- "HsGenPickler.ag"(line 88, column 17)
            (_hdOnumber@_) =
                _lhsInumber
            -- "HsGenPickler.ag"(line 87, column 17)
            (_tlOnumber@_) =
                _lhsInumber + 1
            -- use rule
            (_lhsOreadElt@_) =
                _hdIreadElt : _tlIreadElt
            -- use rule
            (_lhsOwriteD@_) =
                _hdIwriteD : _tlIwriteD
            -- copy rule (up)
            (_lhsOnumber@_) =
                _tlInumber
            -- copy rule (down)
            (_hdOdefname@_) =
                _lhsIdefname
            -- copy rule (down)
            (_tlOdefname@_) =
                _lhsIdefname
        in  ( _lhsOnumber,_lhsOreadElt,_lhsOwriteD)
sem_Constrs_Nil :: (T_Constrs)
sem_Constrs_Nil  =
    \ _lhsIdefname
      _lhsInumber ->
        let _lhsOnumber :: (Int)
            _lhsOreadElt :: ([(String,[(String, Cardinality)])])
            _lhsOwriteD :: ([DeclS])
            -- use rule
            (_lhsOreadElt@_) =
                []
            -- use rule
            (_lhsOwriteD@_) =
                []
            -- copy rule (chain)
            (_lhsOnumber@_) =
                _lhsInumber
        in  ( _lhsOnumber,_lhsOreadElt,_lhsOwriteD)
-- Decl --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      mkHsDecl             : [DeclS]

-}
{-
   local variables for Decl.Module:

-}
-- semantic domain
type T_Decl = ( ([DeclS]))
-- cata
sem_Decl :: (Decl) ->
            (T_Decl)
sem_Decl ((Module (_name) (_defs))) =
    (sem_Decl_Module (_name) ((sem_Definitions (_defs))))
data Inh_Decl = Inh_Decl {}
data Syn_Decl = Syn_Decl {mkHsDecl_Syn_Decl :: [DeclS]}
wrap_Decl :: (T_Decl) ->
             (Inh_Decl) ->
             (Syn_Decl)
wrap_Decl (sem) ((Inh_Decl )) =
    let ( s1) =
            (sem )
    in  (Syn_Decl (s1))
sem_Decl_Module :: (String) ->
                   (T_Definitions) ->
                   (T_Decl)
sem_Decl_Module (name_) (defs_) =
    let _lhsOmkHsDecl :: ([DeclS])
        _defsImkHsDecl :: ([DeclS])
        ( _defsImkHsDecl) =
            (defs_ )
        -- "HsGenPickler.ag"(line 46, column 7)
        (_lhsOmkHsDecl@_) =
            _defsImkHsDecl
    in  ( _lhsOmkHsDecl)
-- Decls -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      mkHsDecl             : [DeclS]

-}
{-
   local variables for Decls.Cons:

-}
{-
   local variables for Decls.Nil:

-}
-- semantic domain
type T_Decls = ( ([DeclS]))
-- cata
sem_Decls :: (Decls) ->
             (T_Decls)
sem_Decls (list) =
    (Prelude.foldr (sem_Decls_Cons) (sem_Decls_Nil) ((Prelude.map sem_Decl list)))
data Inh_Decls = Inh_Decls {}
data Syn_Decls = Syn_Decls {mkHsDecl_Syn_Decls :: [DeclS]}
wrap_Decls :: (T_Decls) ->
              (Inh_Decls) ->
              (Syn_Decls)
wrap_Decls (sem) ((Inh_Decls )) =
    let ( s1) =
            (sem )
    in  (Syn_Decls (s1))
sem_Decls_Cons :: (T_Decl) ->
                  (T_Decls) ->
                  (T_Decls)
sem_Decls_Cons (hd_) (tl_) =
    let _lhsOmkHsDecl :: ([DeclS])
        _hdImkHsDecl :: ([DeclS])
        _tlImkHsDecl :: ([DeclS])
        ( _hdImkHsDecl) =
            (hd_ )
        ( _tlImkHsDecl) =
            (tl_ )
        -- use rule
        (_lhsOmkHsDecl@_) =
            _hdImkHsDecl ++ _tlImkHsDecl
    in  ( _lhsOmkHsDecl)
sem_Decls_Nil :: (T_Decls)
sem_Decls_Nil  =
    let _lhsOmkHsDecl :: ([DeclS])
        -- use rule
        (_lhsOmkHsDecl@_) =
            []
    in  ( _lhsOmkHsDecl)
-- Definition --------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      mkHsDecl             : [DeclS]

-}
{-
   local variables for Definition.Def:
      upkl_ty_sig
      pkl_ty_sig

-}
-- semantic domain
type T_Definition = ( ([DeclS]))
-- cata
sem_Definition :: (Definition) ->
                  (T_Definition)
sem_Definition ((Def (_name) (_dtype))) =
    (sem_Definition_Def (_name) ((sem_AsdlType (_dtype))))
data Inh_Definition = Inh_Definition {}
data Syn_Definition = Syn_Definition {mkHsDecl_Syn_Definition :: [DeclS]}
wrap_Definition :: (T_Definition) ->
                   (Inh_Definition) ->
                   (Syn_Definition)
wrap_Definition (sem) ((Inh_Definition )) =
    let ( s1) =
            (sem )
    in  (Syn_Definition (s1))
sem_Definition_Def :: (String) ->
                      (T_AsdlType) ->
                      (T_Definition)
sem_Definition_Def (name_) (dtype_) =
    let _lhsOmkHsDecl :: ([DeclS])
        _dtypeIreadD :: (DeclS)
        _dtypeIwriteD :: ([DeclS])
        _dtypeOdefname :: (String)
        ( _dtypeIreadD,_dtypeIwriteD) =
            (dtype_ (_dtypeOdefname))
        -- "HsGenPickler.ag"(line 61, column 7)
        (_dtypeOdefname@_) =
            haskellName name_
        -- "HsGenPickler.ag"(line 60, column 7)
        (_upkl_ty_sig@_) =
            readPickleSig (haskellName name_)
        -- "HsGenPickler.ag"(line 59, column 7)
        (_pkl_ty_sig@_) =
            writePickleSig (haskellName name_)
        -- "HsGenPickler.ag"(line 55, column 7)
        (_lhsOmkHsDecl@_) =
            (_pkl_ty_sig     : _dtypeIwriteD)
            ++ [_upkl_ty_sig    , _dtypeIreadD]
    in  ( _lhsOmkHsDecl)
-- Definitions -------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      mkHsDecl             : [DeclS]

-}
{-
   local variables for Definitions.Cons:

-}
{-
   local variables for Definitions.Nil:

-}
-- semantic domain
type T_Definitions = ( ([DeclS]))
-- cata
sem_Definitions :: (Definitions) ->
                   (T_Definitions)
sem_Definitions (list) =
    (Prelude.foldr (sem_Definitions_Cons) (sem_Definitions_Nil) ((Prelude.map sem_Definition list)))
data Inh_Definitions = Inh_Definitions {}
data Syn_Definitions = Syn_Definitions {mkHsDecl_Syn_Definitions :: [DeclS]}
wrap_Definitions :: (T_Definitions) ->
                    (Inh_Definitions) ->
                    (Syn_Definitions)
wrap_Definitions (sem) ((Inh_Definitions )) =
    let ( s1) =
            (sem )
    in  (Syn_Definitions (s1))
sem_Definitions_Cons :: (T_Definition) ->
                        (T_Definitions) ->
                        (T_Definitions)
sem_Definitions_Cons (hd_) (tl_) =
    let _lhsOmkHsDecl :: ([DeclS])
        _hdImkHsDecl :: ([DeclS])
        _tlImkHsDecl :: ([DeclS])
        ( _hdImkHsDecl) =
            (hd_ )
        ( _tlImkHsDecl) =
            (tl_ )
        -- use rule
        (_lhsOmkHsDecl@_) =
            _hdImkHsDecl ++ _tlImkHsDecl
    in  ( _lhsOmkHsDecl)
sem_Definitions_Nil :: (T_Definitions)
sem_Definitions_Nil  =
    let _lhsOmkHsDecl :: ([DeclS])
        -- use rule
        (_lhsOmkHsDecl@_) =
            []
    in  ( _lhsOmkHsDecl)
-- Field -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      picklr               : (String, Cardinality)
      unpick               : (String, Cardinality)

-}
{-
   local variables for Field.Field:

-}
-- semantic domain
type T_Field = ( ((String, Cardinality)),((String, Cardinality)))
-- cata
sem_Field :: (Field) ->
             (T_Field)
sem_Field ((Field (_qual) (_ptype) (_card) (_opt_name))) =
    (sem_Field_Field ((sem_OptQualifier (_qual))) ((sem_AsdlPrim (_ptype))) ((sem_Cardinality (_card))) ((sem_OptIdentifier (_opt_name))))
data Inh_Field = Inh_Field {}
data Syn_Field = Syn_Field {picklr_Syn_Field :: (String, Cardinality),unpick_Syn_Field :: (String, Cardinality)}
wrap_Field :: (T_Field) ->
              (Inh_Field) ->
              (Syn_Field)
wrap_Field (sem) ((Inh_Field )) =
    let ( s1,s2) =
            (sem )
    in  (Syn_Field (s1) (s2))
sem_Field_Field :: (T_OptQualifier) ->
                   (T_AsdlPrim) ->
                   (T_Cardinality) ->
                   (T_OptIdentifier) ->
                   (T_Field)
sem_Field_Field (qual_) (ptype_) (card_) (opt_name_) =
    let _lhsOpicklr :: ((String, Cardinality))
        _lhsOunpick :: ((String, Cardinality))
        _ptypeIpickler_name :: (String)
        _ptypeIunpickler_name :: (String)
        _cardIidentity :: (Cardinality)
        ( _ptypeIpickler_name,_ptypeIunpickler_name) =
            (ptype_ )
        ( _cardIidentity) =
            (card_ )
        -- "HsGenPickler.ag"(line 117, column 25)
        (_lhsOunpick@_) =
            (_ptypeIunpickler_name,_cardIidentity)
        -- "HsGenPickler.ag"(line 116, column 25)
        (_lhsOpicklr@_) =
            (_ptypeIpickler_name,_cardIidentity)
    in  ( _lhsOpicklr,_lhsOunpick)
-- Fields ------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      picklr               : [(String, Cardinality)]
      unpick               : [(String, Cardinality)]

-}
{-
   local variables for Fields.Cons:

-}
{-
   local variables for Fields.Nil:

-}
-- semantic domain
type T_Fields = ( ([(String, Cardinality)]),([(String, Cardinality)]))
-- cata
sem_Fields :: (Fields) ->
              (T_Fields)
sem_Fields (list) =
    (Prelude.foldr (sem_Fields_Cons) (sem_Fields_Nil) ((Prelude.map sem_Field list)))
data Inh_Fields = Inh_Fields {}
data Syn_Fields = Syn_Fields {picklr_Syn_Fields :: [(String, Cardinality)],unpick_Syn_Fields :: [(String, Cardinality)]}
wrap_Fields :: (T_Fields) ->
               (Inh_Fields) ->
               (Syn_Fields)
wrap_Fields (sem) ((Inh_Fields )) =
    let ( s1,s2) =
            (sem )
    in  (Syn_Fields (s1) (s2))
sem_Fields_Cons :: (T_Field) ->
                   (T_Fields) ->
                   (T_Fields)
sem_Fields_Cons (hd_) (tl_) =
    let _lhsOpicklr :: ([(String, Cardinality)])
        _lhsOunpick :: ([(String, Cardinality)])
        _hdIpicklr :: ((String, Cardinality))
        _hdIunpick :: ((String, Cardinality))
        _tlIpicklr :: ([(String, Cardinality)])
        _tlIunpick :: ([(String, Cardinality)])
        ( _hdIpicklr,_hdIunpick) =
            (hd_ )
        ( _tlIpicklr,_tlIunpick) =
            (tl_ )
        -- use rule
        (_lhsOpicklr@_) =
            _hdIpicklr : _tlIpicklr
        -- use rule
        (_lhsOunpick@_) =
            _hdIunpick : _tlIunpick
    in  ( _lhsOpicklr,_lhsOunpick)
sem_Fields_Nil :: (T_Fields)
sem_Fields_Nil  =
    let _lhsOpicklr :: ([(String, Cardinality)])
        _lhsOunpick :: ([(String, Cardinality)])
        -- use rule
        (_lhsOpicklr@_) =
            []
        -- use rule
        (_lhsOunpick@_) =
            []
    in  ( _lhsOpicklr,_lhsOunpick)
-- OptIdentifier -----------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptIdentifier.Just:

-}
{-
   local variables for OptIdentifier.Nothing:

-}
-- semantic domain
type T_OptIdentifier = ( )
-- cata
sem_OptIdentifier :: (OptIdentifier) ->
                     (T_OptIdentifier)
sem_OptIdentifier ((Prelude.Just (x))) =
    (sem_OptIdentifier_Just (x))
sem_OptIdentifier (Prelude.Nothing) =
    sem_OptIdentifier_Nothing
data Inh_OptIdentifier = Inh_OptIdentifier {}
data Syn_OptIdentifier = Syn_OptIdentifier {}
wrap_OptIdentifier :: (T_OptIdentifier) ->
                      (Inh_OptIdentifier) ->
                      (Syn_OptIdentifier)
wrap_OptIdentifier (sem) ((Inh_OptIdentifier )) =
    let 
    in  (Syn_OptIdentifier )
sem_OptIdentifier_Just :: (String) ->
                          (T_OptIdentifier)
sem_OptIdentifier_Just (just_) =
    let 
    in  ( )
sem_OptIdentifier_Nothing :: (T_OptIdentifier)
sem_OptIdentifier_Nothing  =
    let 
    in  ( )
-- OptQualifier ------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for OptQualifier.Just:

-}
{-
   local variables for OptQualifier.Nothing:

-}
-- semantic domain
type T_OptQualifier = ( )
-- cata
sem_OptQualifier :: (OptQualifier) ->
                    (T_OptQualifier)
sem_OptQualifier ((Prelude.Just (x))) =
    (sem_OptQualifier_Just (x))
sem_OptQualifier (Prelude.Nothing) =
    sem_OptQualifier_Nothing
data Inh_OptQualifier = Inh_OptQualifier {}
data Syn_OptQualifier = Syn_OptQualifier {}
wrap_OptQualifier :: (T_OptQualifier) ->
                     (Inh_OptQualifier) ->
                     (Syn_OptQualifier)
wrap_OptQualifier (sem) ((Inh_OptQualifier )) =
    let 
    in  (Syn_OptQualifier )
sem_OptQualifier_Just :: (String) ->
                         (T_OptQualifier)
sem_OptQualifier_Just (just_) =
    let 
    in  ( )
sem_OptQualifier_Nothing :: (T_OptQualifier)
sem_OptQualifier_Nothing  =
    let 
    in  ( )


