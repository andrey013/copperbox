

{
module Gen.Ext.Haskell.HsGenPickler
  ( makeHsPicklerCode
  ) where


import Base.Lib
import Ext.Haskell.HsSyntax
import Ext.Haskell.HsCodeFragments
import Ext.Haskell.CodeGen
import Util.Naming


import qualified Language.Haskell.Syntax as HS
  
}



INCLUDE "Gen/Base/AsdlCoreAbsSynDEFS.ag"


ATTR AsdlSpec [ base_name : {String} | | mkModule : {ModuleS} ]

SEM AsdlSpec
  | AsdlSpec    
      lhs.mkModule        = moduleD (moduleN @loc.hs_mod_name) 
                                    [] 
                                    [ importD (moduleN "AsdlBase") False Nothing Nothing
                                    , importD (moduleN (@lhs.base_name ++ "AbsSyn")) False Nothing Nothing
                                    ]
                                    @decls.mkHsDecl                                   
                                    
      loc.hs_mod_name     = @lhs.base_name ++ "Pkl"
                                                            
      

ATTR Decls [ | | mkHsDecl USE {++} {[]} : {[DeclS]} ]

ATTR Decl [ | | mkHsDecl : {[DeclS]} ]

SEM Decl
  | Module
      lhs.mkHsDecl        = @defs.mkHsDecl

ATTR Definitions [ | | mkHsDecl USE {++} {[]} : {[DeclS]} ]


ATTR Definition [ | | mkHsDecl : {[DeclS]} ]

SEM Definition
  | Def 
      lhs.mkHsDecl        = (@loc.pkl_ty_sig : @dtype.writeD) 
                            ++ [@loc.upkl_ty_sig, @dtype.readD]

                                 
      loc.pkl_ty_sig      = writePickleSig (haskellName @name)
      loc.upkl_ty_sig     = readPickleSig (haskellName @name)
      dtype.defname       = haskellName @name


ATTR AsdlType Constrs  Constr [ defname : {String} | | ]
                              
ATTR AsdlType [  | | writeD : {[DeclS]} ]
ATTR AsdlType [  | | readD : {DeclS} ]


SEM AsdlType
  | Sum
      lhs.writeD          = @constrs.writeD
      lhs.readD           = dtypeReadD @lhs.defname @constrs.readElt
      constrs.number      = 1
  | Prod  
      lhs.writeD          = [tuplePicklerD @lhs.defname @fields.picklr]
      lhs.readD           = tupleReadD @lhs.defname @fields.unpick

ATTR Constrs [ | | writeD USE {:} {[]} : {[DeclS]} ]

ATTR Constrs [ | | readElt USE {:} {[]} : {[(String,[(String, Cardinality)])]} ]


ATTR Constrs [ | number : Int |  ]

SEM Constrs 
  | Cons        tl.number = @lhs.number + 1 
                hd.number = @lhs.number



ATTR Constr [ number : Int | | ]
ATTR Constr [ | | writeD : {DeclS} ]

SEM Constr
  | Constr
      lhs.writeD          = constrPicklerD @lhs.defname 
                                           @label
                                           @lhs.number
                                           @fields.picklr

ATTR Constr [ | | readElt : {(String,[(String, Cardinality)])} ]

SEM Constr
  | Constr
      lhs.readElt         = (@label, @fields.unpick)


ATTR Fields [ | | picklr USE {:} {[]} : {[(String, Cardinality)]} ]
ATTR Fields [ | | unpick USE {:} {[]} : {[(String, Cardinality)]} ]

ATTR Field [ | | picklr  : {(String, Cardinality)} ]
ATTR Field [ | | unpick  : {(String, Cardinality)} ]

SEM Field 
  | Field               lhs.picklr    = (@ptype.pickler_name,@card.identity)
                        lhs.unpick    = (@ptype.unpickler_name,@card.identity)
                        
ATTR AsdlPrim [ | | pickler_name  : {String} ]

SEM AsdlPrim
  | TyUnit              lhs.pickler_name    = "punit"
  | TyString            lhs.pickler_name    = "pstring"
  | TyInt               lhs.pickler_name    = "pint"
  | TyIdentifier        lhs.pickler_name    = "pstring"
  | TyRef               lhs.pickler_name    = pname $ haskellName @name
  | TyExternalPrim      lhs.pickler_name    = pname $ haskellName @name

ATTR AsdlPrim [ | | unpickler_name  : {String} ]

SEM AsdlPrim
  | TyUnit              lhs.unpickler_name  = "uunit"
  | TyString            lhs.unpickler_name  = "ustring"
  | TyInt               lhs.unpickler_name  = "uint"
  | TyIdentifier        lhs.unpickler_name  = "ustring"
  | TyRef               lhs.unpickler_name  = uname $ haskellName @name
  | TyExternalPrim      lhs.unpickler_name  = uname $ haskellName @name
  

ATTR Cardinality  [ | | identity : SELF ]
  
      
{


uname :: String -> String 
uname "Bool"    = "ubool"
uname "Char"    = "uchar"
uname "Float"   = "ufloat"
uname "Int64"   = "uint64"
uname s         = "read" ++ s


pname :: String -> String
pname "Bool"    = "pbool" 
pname "Char"    = "pchar"
pname "Float"   = "pfloat"
pname "Int64"   = "pint64"
pname s         = "write" ++ s


makeHsPicklerCode :: AsdlSpec -> String -> HS.HsModule
makeHsPicklerCode defn name = runCode $ mkModule_Syn_AsdlSpec synthesized
  where synthesized = wrap_AsdlSpec (sem_AsdlSpec defn) inherited
        inherited   = Inh_AsdlSpec name




}  