
{
module Language.C.AG.Pretty (prettyCTranslationUnit) where

import Language.C.Syntax
import Language.C.AG.SyntaxExtra hiding (CInitList)
import Language.C.Position

import PPrint
import PPExt

import Data.Maybe


}

INCLUDE "SyntaxBase.ag"
INCLUDE "SyntaxExtraDEFS.ag"


ATTR CTranslationUnit CExtDecl CDecl CFunDef CDeclSpec CDeclr
     CTypeSpec CStat CExpr CConst CDeclParam CInit CStructUnion
     CEnum CEnumDef CBlockItem CInitialClause
     CAttributeSpec CAttribute
  [ | | pp : {Doc} ]

ATTR CTypeQuals [ | | pp : {[Doc]} ]

ATTR CExtDecls CDeclSpecs CDeclParams CDecls CBlockItems
     CExprs CInitList CEnumDefs CAttributeSpecs CAttributes
  [ | | pp USE {:} {[]} : {[Doc]} ]
     
ATTR OptCExpr OptCStat OptIdent OptCInit OptCDeclr
  [ | | pp : {(Maybe Doc)} ]     



SEM CTranslationUnit
  | CTranslationUnit
        lhs.pp      = vcat2 @ext_decls.pp
        
-- | Declarations are terminated with a semi, definitions aren't.
SEM CExtDecl
  | CDeclExt  
        lhs.pp      = @decl.pp <> semi
  | CFDefExt  
        lhs.pp      = @fun_def.pp
  | CAsmExt   
        lhs.pp      = text "/* ASM */"

SEM CDecl 
  | CDecl 
        lhs.pp      = spaceSep @decl_specs.pp
                               <+> commaSep @decl_params.pp


SEM CFunDef 
  | CFunDef 
        lhs.pp      = sep @decl_specs.pp <+> @declarator.pp
                       <+> sep @declaration_list.pp <$$> @stat.pp


SEM CDeclSpec 
  | CStorageSpec 
        lhs.pp      = pretty @storage_spec
  | CTypeSpec    
        lhs.pp      = @type_spec.pp
  | CTypeQual    
        lhs.pp      = pretty @type_qual



SEM CDeclr 
  | CVarDeclr 
        lhs.pp      = optEmpty @opt_ident.pp
  | CPtrDeclr 
        lhs.pp      = char '*' <> hsep @indirections.pp <> @declr.pp                
  | CArrDeclr
        lhs.pp      = @declr.pp <> brackets (optEmpty @opt_expr.pp)

  | CFunDeclr 
        lhs.pp      = @declr.pp <> parensComma @decls.pp <> @var_doc
        loc.var_doc = case @is_variadic of 
                        True -> text ", ..."
                        False -> empty
                



SEM CTypeSpec 
  | CVoidType    
        lhs.pp      = text "void"
  | CCharType    
        lhs.pp      = text "char"
  | CShortType   
        lhs.pp      = text "short"
  | CIntType     
        lhs.pp      = text "int"
  | CLongType    
        lhs.pp      = text "long"
  | CFloatType   
        lhs.pp      = text "float"
  | CDoubleType  
        lhs.pp      = text "double"
  | CSignedType  
        lhs.pp      = text "signed"
  | CUnsigType   
        lhs.pp      = text "unsigned"
  | CBoolType    
        lhs.pp      = text "_Bool"
  | CComplexType 
        lhs.pp      = text "_Complex"
  | CSUType      
        lhs.pp      = @su_type.pp
  | CEnumType    
        lhs.pp      = text "enum" <+> @enum.pp
  | CTypeDef     
        lhs.pp      = ident @name
  | CTypeOfExpr  
        lhs.pp      = text "typeof" <> parens @expr.pp            
  | CTypeOfType  
        lhs.pp      = text "typeof" <> parens @decl.pp


-- | Statements are responsible for terminating themselves with a semi 
-- if necessary.
SEM CStat 
  | CLabel 
        lhs.pp      = ident @label <> colon <> @stat.pp
  | CCase 
        lhs.pp      = text "case" <+> @expr.pp <> colon <+> @stat.pp
          
  | CCases 
        lhs.pp      = text "case" <+> @lower_expr.pp 
                        <+> text "..." <+> @upper_expr.pp <> colon <+> @stat.pp
    
  | CDefault  
        lhs.pp      = text "default" <> colon <+> @stat.pp
    
  | CExpr 
        lhs.pp      = optEmpty @opt_expr.pp <> semi
  
  | CCompound 
        lhs.pp      = bracesEmptyLinesIndent 3 @block_items.pp                        
  | CIf 
        lhs.pp      = text "if" <> parens @cond_expr.pp <+> @then_stat.pp <+> fromMaybe empty @opt_else.pp
    
  | CSwitch 
        lhs.pp      = text "switch" <> parens @expr.pp <+> @stat.pp
  
  | CWhile 
        lhs.pp      = case @is_dowhile of
                        True -> text "do" <+> @stat.pp <+> text "while" <+> parens @expr.pp <> semi
                        False -> text "while" <+> parens @expr.pp <+> @stat.pp
     
  | CFor 
        lhs.pp      = (text "for" <> parensSemi [@initial_clause.pp,
                                                optEmpty @opt_test_expr.pp,
                                                optEmpty @opt_upd_expr.pp])
                        <$$> @stat.pp  
  | CGoto 
        lhs.pp      = text "goto" <+> ident @ident <> semi
  
  | CCont 
        lhs.pp      = text "continue" <> semi

  | CBreak 
        lhs.pp      = text "break" <> semi

  | CReturn 
        lhs.pp      = text "return" <+> fromMaybe empty @opt_expr.pp <> semi

  | CAsm 
        lhs.pp      = text "/* CAsm */"


ATTR CExpr  [  |  | rator : {Operator} ]

  
SEM CExpr
  | CComma 
        lhs.pp      = commaSep @exprs.pp
        loc.rator   = ("<comma>", 1, Infix LR) 
        
    
  | CAssign 
        lhs.pp      = @lvalue.pp <+> text (first @loc.rator) <+> @rvalue.pp
        loc.rator   = operator @assign_op
    
  | CCond 
        lhs.pp      = @cond_expr.pp
                            <+> char '?' <+> optEmpty @opt_true_expr.pp 
                            <+> char ':' <+> @false_expr.pp
        loc.rator   = ("<ternary>", 3, Primary)
                                  
  | CBinary 
        lhs.pp      = @exp_l <+> text (first @loc.rator) <+> @exp_r
        loc.exp_l   = bracket (@left_expr.rator,@left_expr.pp) LR @loc.rator
        loc.exp_r   = bracket (@right_expr.rator,@right_expr.pp) RL @loc.rator
        loc.rator   = operator @binary_op

  | CCast 
        lhs.pp      = parens @type_decl.pp <+> @expr.pp
        loc.rator   = ("<cast>", 3, Infix RL)

  | CUnary 
        lhs.pp      = case (third @loc.rator) of 
                          Postfix -> @e  <> text (first @loc.rator)
                          Prefix -> text (first @loc.rator) <> @e
                          _ -> error "Unary expression not deemed tyo be pre-post fixed"
        
        loc.e       = bracket (@expr.rator,@expr.pp) NA @loc.rator
        loc.rator   = operator @unary_op                        
    
  | CSizeofExpr 
        lhs.pp      = text "sizeof" <+> parens @expr.pp
        loc.rator   = ("<sizeof_expr>", 15, Infix RL)
    
  | CSizeofType 
        lhs.pp      = text "sizeof" <+> parens @decl.pp
        loc.rator   = ("<sizeof_type>", 15, Infix RL)

  | CAlignofExpr 
        lhs.pp      = text "alignof" <+> parens @expr.pp
        loc.rator   = ("<alignof_expr>", 15, Infix RL)
    
  | CAlignofType 
        lhs.pp      = text "alignof" <+> parens @decl.pp
        loc.rator   = ("<alignof_type>", 15, Infix RL)
    
  | CIndex 
        lhs.pp      = subscript @expr.pp @index_expr.pp
        loc.rator   = ("<subscript>", 16, Postfix)
        
  | CCall 
        lhs.pp      = @expr.pp 
                       <> encloseSep1 lparen rparen commaSpace @args.pp       
        loc.rator   = ("<function_call>", 16, Postfix)
        
  | CMember 
        lhs.pp      = case @is_deref of
                        True -> @expr.pp <> text "->" <> ident @ident
                        False -> @expr.pp <> char '.' <> ident @ident
        loc.rator   = ("<selection>", 16, Postfix)
                                                  
  | CVar 
        lhs.pp      = ident @ident
        loc.rator   = ("<variable>", 16, Primary)
        
  | CConst 
        lhs.pp      = @constant.pp
        loc.rator   = ("<constant>", 16, Primary)
        
  | CCompoundLit 
        lhs.pp      = parens @decl.pp 
                              <+> bracesSpace @init_list.pp
        loc.rator   = ("<comp_lit>", 16, Postfix)
                        
  | CStatExpr 
        lhs.pp      = parens @stat.pp
        loc.rator   = ("<stat_expr>", 15, Infix RL)
        
  | CLabAddrExpr 
        lhs.pp      = text "&&" <> ident @ident
        loc.rator   = ("<addr_expr>", 15, Prefix)
        
  | CBuiltinExpr 
        lhs.pp      = text "<<CPretty: CExpr#CBuiltinExpr not yet implemented!>>"
        loc.rator   = ("<builtin>", 15, Prefix)
 

SEM CConst
  | CIntConst 
        lhs.pp      = integer @value 
  | CCharConst 
        lhs.pp      = squotes (char @value)
  | CFloatConst 
        lhs.pp      = text @value
  | CStrConst 
        lhs.pp      = dquotes (text @value)


SEM CDeclParam 
  | Tuple   
        lhs.pp      = optEmpty @opt_declarator.pp
                      <+?> @opt_initializer.pp
                      <+?> @opt_expr.pp
                                      

SEM CInit 
  | CInitExpr 
        lhs.pp      = @expr.pp 
  | CInitList 
        lhs.pp      = hsep @init_list.pp
        

SEM CStructUnion 
  | CStruct
        lhs.pp      = pretty @tag <+?> optSpaceSep @attr_specs.pp
                                  <+?> @opt_ident.pp
                                  <+?> structSep @decls.pp 

SEM CEnum 
  | CEnum
        lhs.pp      = hsep @attr_specs.pp 
                        <+?> @opt_ident.pp
                        <+?> enumSep @enum_defs.pp 

        
                                                  
SEM CEnumDef
  | Tuple
        lhs.pp      = ident @name <> (text " = " `prefixJust` @opt_value.pp)


-- | Declarations inside blocks must terminate with a semi
SEM CBlockItem 
  | CBlockStmt    
        lhs.pp      = @stat.pp
  | CBlockDecl    
        lhs.pp      = @decl.pp <> semi
  | CNestedFunDef 
        lhs.pp      = @fundef.pp

SEM CInitialClause   
  | Left  
        lhs.pp      = optEmpty @opt_expr.pp
  | Right  
        lhs.pp      = @decl.pp


SEM CAttributeSpec 
  | CAttributeSpec 
        lhs.pp      = text "__attribute__" <> dparens (hsep @attr_list.pp)


SEM CAttribute 
  | CAttribute
        lhs.pp      = ident @name 
                        <> fromMaybe empty (attribSep @constant_exprs.pp)

      
                
                                        
SEM OptCExpr
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing

SEM OptCStat
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing   
        
SEM OptIdent 
  | Just 
        lhs.pp      = Just (ident @just)
  | Nothing  
        lhs.pp      = Nothing   


SEM OptCInit
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing 

SEM OptCDeclr
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing 
        
SEM CTypeQuals
  | Cons
        lhs.pp      = pretty @hd : @tl.pp
  | Nil 
        lhs.pp      = []




{

data Assoc = LR | RL | NA
  deriving (Eq,Show)

data Fixity = Prefix | Postfix | Infix Assoc | Primary
  deriving (Eq,Show)

type Precedence = Int 

type Operator = (String,Precedence, Fixity)



maxprec = 16
maxrator = ("<max-precedence sentinel>", maxprec, Infix NA)


first  (a,_,_) = a
second (_,b,_) = b
third  (_,_,c) = c


class Rator a where
  operator :: a -> Operator

instance Rator CUnaryOp where 
  operator CPostIncOp   = ("++", 16, Postfix)
  operator CPostDecOp   = ("--", 16, Postfix)
  operator CPreIncOp    = ("++", 15, Prefix)
  operator CPreDecOp    = ("--", 15, Prefix)
  operator CAdrOp       = ("&",  15, Prefix)
  operator CIndOp       = ("*",  15, Prefix)
  operator CPlusOp      = ("+",  15, Prefix)
  operator CMinOp       = ("-",  15, Prefix)
  operator CCompOp      = ("~",  15, Prefix)
  operator CNegOp       = ("!",  15, Prefix)  
  
instance Rator CBinaryOp where
  operator CMulOp     = ("*",  13, Infix LR)
  operator CDivOp     = ("/",  13, Infix LR)
  operator CRmdOp     = ("%",  13, Infix LR)
  operator CAddOp     = ("+",  12, Infix LR)
  operator CSubOp     = ("-",  12, Infix LR)
  operator CShlOp     = ("<<", 11, Infix LR)
  operator CShrOp     = (">>", 11, Infix LR)
  operator CLeOp      = ("<",  10, Infix LR)
  operator CGrOp      = (">",  10, Infix LR)
  operator CLeqOp     = ("<=", 10, Infix LR)
  operator CGeqOp     = (">=", 10, Infix LR)
  operator CEqOp      = ("==",  9, Infix LR)
  operator CNeqOp     = ("!=",  9, Infix LR)
  operator CAndOp     = ("&",   8, Infix LR)
  operator CXorOp     = ("^",   7, Infix LR)
  operator COrOp      = ("|",   6, Infix LR)
  operator CLndOp     = ("&&",  5, Infix LR)
  operator CLorOp     = ("||",  4, Infix LR)
  
instance Rator CAssignOp where
  operator CAssignOp    = ("=",   2, Infix RL)
  operator CMulAssOp    = ("*=",  2, Infix RL)
  operator CDivAssOp    = ("/=",  2, Infix RL)
  operator CRmdAssOp    = ("%=",  2, Infix RL)
  operator CAddAssOp    = ("+=",  2, Infix RL)
  operator CSubAssOp    = ("-=",  2, Infix RL)
  operator CShlAssOp    = ("<<=", 2, Infix RL)
  operator CShrAssOp    = (">>=", 2, Infix RL)
  operator CAndAssOp    = ("&=",  2, Infix RL)
  operator CXorAssOp    = ("^=",  2, Infix RL)
  operator COrAssOp     = ("|=",  2, Infix RL)
          
  

instance Pretty CStructTag where
  pretty CStructTag   = text "struct"
  pretty CUnionTag    = text "union"

instance Pretty CStorageSpec where
  pretty (CAuto     _) = text "auto"
  pretty (CRegister _) = text "register"
  pretty (CStatic   _) = text "static"
  pretty (CExtern   _) = text "extern"
  pretty (CTypedef  _) = text "typedef"
  
  
instance Pretty CTypeQual where
  pretty (CConstQual _) = text "const"
  pretty (CVolatQual _) = text "volatile"
  pretty (CRestrQual _) = text "restrict"
  



type Fragment = (Operator, Doc)  

bracket :: Fragment -> Assoc -> Operator -> Doc
bracket (inner,doc) side outer 
    | noparens inner outer side == True = doc
    | otherwise                         = parens doc

                              
noparens :: Operator -> Operator -> Assoc -> Bool              
noparens (_,pi,fi) (_,po, fo) side
  | pi > po   = True
  | otherwise = 
    case (fi, side) of
      (Primary,   _) -> True
      (Postfix,  LR) -> True
      (Prefix,   RL) -> True
      (Infix LR, LR) -> pi == po && fo == Infix LR
      (Infix RL, RL) -> pi == po && fo == Infix RL
      (_,        NA) -> fi == fo
      _              -> False

ident :: Ident -> Doc
ident  = text . identToLexeme


prettyCTranslationUnit :: CTranslationUnit -> Doc
prettyCTranslationUnit header = pp_Syn_CTranslationUnit synthesized
  where synthesized = wrap_CTranslationUnit (sem_CTranslationUnit header) inherited
        inherited   = Inh_CTranslationUnit
          
}  