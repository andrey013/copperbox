
{
module Language.C.AG.Pretty (prettyCTranslationUnit) where

import Language.C.Syntax
import Language.C.AG.SyntaxExtra hiding (CInitList)
import Language.C.Position

import PPrint
import PPExt

import Data.Maybe


}

INCLUDE "SyntaxBase.ag"
INCLUDE "SyntaxExtraDEFS.ag"


ATTR CTranslationUnit CExtDecl CDecl CFunDef CDeclSpec CDeclr
     CTypeSpec CStat CExpr CConst CDeclParam CInit CStructUnion
     CEnum CEnumDef CBlockItem CInitialClause
  [ | | pp : {Doc} ]

ATTR CTypeQuals [ | | pp : {[Doc]} ]

ATTR CExtDecls CDeclSpecs CDeclParams CDecls CBlockItems
     CExprs CInitList CEnumDefs
  [ | | pp USE {:} {[]} : {[Doc]} ]
     
ATTR OptCExpr OptCStat OptIdent OptCInit OptCDeclr
  [ | | pp : {(Maybe Doc)} ]     



SEM CTranslationUnit
  | CTranslationUnit
        lhs.pp      = vcat2 (postPunctuate semi @ext_decls.pp)
        

SEM CExtDecl
  | CDeclExt  
        lhs.pp      = @decl.pp
  | CFDefExt  
        lhs.pp      = @fun_def.pp
  | CAsmExt   
        lhs.pp      = text "/* ASM */"

SEM CDecl 
  | CDecl 
        lhs.pp      = spaceSep @decl_specs.pp
                               <+> commaSep @decl_params.pp


SEM CFunDef 
  | CFunDef 
        lhs.pp      = sep @decl_specs.pp <+> @declarator.pp
                       <+> sep @declaration_list.pp <$$> @stat.pp


SEM CDeclSpec 
  | CStorageSpec 
        lhs.pp      = pretty @storage_spec
  | CTypeSpec    
        lhs.pp      = @type_spec.pp
  | CTypeQual    
        lhs.pp      = pretty @type_qual



SEM CDeclr 
  | CVarDeclr 
        lhs.pp      = optEmpty @opt_ident.pp
  | CPtrDeclr 
        lhs.pp      = char '*' <> hsep @indirections.pp <> @declr.pp                
  | CArrDeclr
        lhs.pp      = @declr.pp <> brackets (optEmpty @opt_expr.pp)

  | CFunDeclr 
        lhs.pp      = @declr.pp <> parensComma @decls.pp <> @var_doc
        loc.var_doc = case @is_variadic of 
                        True -> text ", ..."
                        False -> empty
                



SEM CTypeSpec 
  | CVoidType    
        lhs.pp      = text "void"
  | CCharType    
        lhs.pp      = text "char"
  | CShortType   
        lhs.pp      = text "short"
  | CIntType     
        lhs.pp      = text "int"
  | CLongType    
        lhs.pp      = text "long"
  | CFloatType   
        lhs.pp      = text "float"
  | CDoubleType  
        lhs.pp      = text "double"
  | CSignedType  
        lhs.pp      = text "signed"
  | CUnsigType   
        lhs.pp      = text "unsigned"
  | CBoolType    
        lhs.pp      = text "_Bool"
  | CComplexType 
        lhs.pp      = text "_Complex"
  | CSUType      
        lhs.pp      = @su_type.pp
  | CEnumType    
        lhs.pp      = text "enum" <+> @enum.pp
  | CTypeDef     
        lhs.pp      = ident @name
  | CTypeOfExpr  
        lhs.pp      = text "typeof" <> parens @expr.pp            
  | CTypeOfType  
        lhs.pp      = text "typeof" <> parens @decl.pp

-- | Statements are responsible for terminating themselves with a semi 
-- if necessary.
SEM CStat 
  | CLabel 
        lhs.pp      = ident @label <> colon <> @stat.pp
  | CCase 
        lhs.pp      = text "case" <+> @expr.pp <> colon <+> @stat.pp
          
  | CCases 
        lhs.pp      = text "case" <+> @lower_expr.pp 
                        <+> text "..." <+> @upper_expr.pp <> colon <+> @stat.pp
    
  | CDefault  
        lhs.pp      = text "default" <> colon <+> @stat.pp
    
  | CExpr 
        lhs.pp      = optEmpty @opt_expr.pp <> semi
  
  | CCompound 
        lhs.pp      = bracesEmptyLinesIndent 3 @block_items.pp                        
  | CIf 
        lhs.pp      = text "if" <> parens @cond_expr.pp <+> @then_stat.pp <+> fromMaybe empty @opt_else.pp
    
  | CSwitch 
        lhs.pp      = text "switch" <> parens @expr.pp <+> @stat.pp
  
  | CWhile 
        lhs.pp      = case @is_dowhile of
                        True -> text "do" <+> @stat.pp <+> text "while" <+> parens @expr.pp <> semi
                        False -> text "while" <+> parens @expr.pp <+> @stat.pp
     
  | CFor 
        lhs.pp      = (text "for" <> parensSemi [@initial_clause.pp,
                                                optEmpty @opt_test_expr.pp,
                                                optEmpty @opt_upd_expr.pp])
                        <$$> @stat.pp  
  | CGoto 
        lhs.pp      = text "goto" <+> ident @ident <> semi
  
  | CCont 
        lhs.pp      = text "continue" <> semi

  | CBreak 
        lhs.pp      = text "break" <> semi

  | CReturn 
        lhs.pp      = text "return" <+> fromMaybe empty @opt_expr.pp <> semi

  | CAsm 
        lhs.pp      = text "/* CAsm */"



SEM CExpr
  | CComma 
        lhs.pp      = commaSep @exprs.pp
    
  | CAssign 
        lhs.pp      = @lvalue.pp <+> pretty @assign_op <+> @rvalue.pp
    
  | CCond 
        lhs.pp      = @cond_expr.pp
                        <+> char '?' <+> optEmpty @opt_true_expr.pp 
                        <+> char ':' <+> @false_expr.pp
  | CBinary 
        lhs.pp      = @left_expr.pp <+> pretty @binary_op <+> @right_expr.pp

  | CCast 
        lhs.pp      = parens @type_decl.pp <+> @expr.pp

  | CUnary 
        lhs.pp      = case isPrefixOp @unary_op of 
                        True -> pretty @unary_op <> @expr.pp
                        False -> @expr.pp <> pretty @unary_op
    
  | CSizeofExpr 
        lhs.pp      = text "sizeof" <+> @expr.pp
    
  | CSizeofType 
        lhs.pp      = text "sizeof" <+> parens @decl.pp

  | CAlignofExpr 
        lhs.pp      = text "alignof" <+> @expr.pp
    
  | CAlignofType 
        lhs.pp      = text "alignof" <+> parens @decl.pp
    
  | CIndex 
        lhs.pp      = @expr.pp <> lbracket <> @index_expr.pp <> rbracket                          

  | CCall 
        lhs.pp      = @expr.pp 
                        <> encloseSep1 lparen rparen commaSpace @args.pp       

  | CMember 
        lhs.pp      = case @is_deref of
                        True -> @expr.pp <> text "->" <> ident @ident
                        False -> @expr.pp <> char '.' <> ident @ident
                                                  
  | CVar 
        lhs.pp      = ident @ident
        
  | CConst 
        lhs.pp      = @constant.pp
        
  | CCompoundLit 
        lhs.pp      = parens @decl.pp 
                        <+> bracesSpace @init_list.pp
                        
  | CStatExpr 
        lhs.pp      = parens @stat.pp
        
  | CLabAddrExpr 
        lhs.pp      = text "&&" <> ident @ident
        
  | CBuiltinExpr 
        lhs.pp      = text "<<CPretty: CExpr#CBuiltinExpr not yet implemented!>>"

 

SEM CConst
  | CIntConst 
        lhs.pp      = integer @value 
  | CCharConst 
        lhs.pp      = squotes (char @value)
  | CFloatConst 
        lhs.pp      = text @value
  | CStrConst 
        lhs.pp      = dquotes (text @value)


SEM CDeclParam 
  | Tuple   
        lhs.pp      = optEmpty @opt_declarator.pp
                      <+?> @opt_initializer.pp
                      <+?> @opt_expr.pp
                                      

SEM CInit 
  | CInitExpr 
        lhs.pp      = @expr.pp 
  | CInitList 
        lhs.pp      = hsep @init_list.pp
        

SEM CStructUnion 
  | CStruct
        lhs.pp      = pretty @tag <+?> @opt_ident.pp
                        <+?> structSep @decls.pp 

SEM CEnum 
  | CEnum
        lhs.pp      = fromMaybe empty @opt_ident.pp
                        <+?> enumSep @enum_defs.pp 

        
                                                  
SEM CEnumDef
  | Tuple
        lhs.pp      = ident @name <> (text " = " `prefixJust` @opt_value.pp)


-- | Declarations inside blocks must terminate with a semi
SEM CBlockItem 
  | CBlockStmt    
        lhs.pp      = @stat.pp
  | CBlockDecl    
        lhs.pp      = @decl.pp <> semi
  | CNestedFunDef 
        lhs.pp      = @fundef.pp

SEM CInitialClause   
  | Left  
        lhs.pp      = optEmpty @opt_expr.pp
  | Right  
        lhs.pp      = @decl.pp
        
                                        
SEM OptCExpr
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing

SEM OptCStat
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing   
        
SEM OptIdent 
  | Just 
        lhs.pp      = Just (ident @just)
  | Nothing  
        lhs.pp      = Nothing   


SEM OptCInit
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing 

SEM OptCDeclr
  | Just 
        lhs.pp      = Just @just.pp
  | Nothing  
        lhs.pp      = Nothing 
        
SEM CTypeQuals
  | Cons
        lhs.pp      = pretty @hd : @tl.pp
  | Nil 
        lhs.pp      = []
                

{

instance Pretty CStructTag where
  pretty CStructTag   = text "struct"
  pretty CUnionTag    = text "union"

instance Pretty CStorageSpec where
  pretty (CAuto     _) = text "auto"
  pretty (CRegister _) = text "register"
  pretty (CStatic   _) = text "static"
  pretty (CExtern   _) = text "extern"
  pretty (CTypedef  _) = text "typedef"
  
  
instance Pretty CTypeQual where
  pretty (CConstQual _) = text "const"
  pretty (CVolatQual _) = text "volatile"
  pretty (CRestrQual _) = text "restrict"
  
  
instance Pretty CAssignOp where
  pretty CAssignOp    = char '='
  pretty CMulAssOp    = text "*="
  pretty CDivAssOp    = text "/="
  pretty CRmdAssOp    = text "%="
  pretty CAddAssOp    = text "+="
  pretty CSubAssOp    = text "-="
  pretty CShlAssOp    = text "<<="
  pretty CShrAssOp    = text ">>="
  pretty CAndAssOp    = text "&="
  pretty CXorAssOp    = text "^="
  pretty COrAssOp     = text "|="
         
           
instance Pretty CBinaryOp where
  pretty CMulOp     = char '*'
  pretty CDivOp     = char '/'
  pretty CRmdOp     = char '%'
  pretty CAddOp     = char '+'
  pretty CSubOp     = char '-'
  pretty CShlOp     = text "<<"
  pretty CShrOp     = text ">>"
  pretty CLeOp      = char '<'
  pretty CGrOp      = char '>'
  pretty CLeqOp     = text "<="
  pretty CGeqOp     = text ">="
  pretty CEqOp      = text "=="
  pretty CNeqOp     = text "!="
  pretty CAndOp     = char '&'
  pretty CXorOp     = char '^'
  pretty COrOp      = char '|'
  pretty CLndOp     = text "&&"
  pretty CLorOp     = text "||"
  
instance Pretty CUnaryOp where 
  pretty CPreIncOp    = text "++"
  pretty CPreDecOp    = text "--"
  pretty CPostIncOp   = text "++"
  pretty CPostDecOp   = text "--"
  pretty CAdrOp       = char '&'
  pretty CIndOp       = char '*'
  pretty CPlusOp      = char '+'
  pretty CMinOp       = char '-'
  pretty CCompOp      = char '~'
  pretty CNegOp       = char '!'  

isPrefixOp :: CUnaryOp -> Bool
isPrefixOp CPostIncOp   = False
isPrefixOp CPostDecOp   = False
isPrefixOp _            = True

ident :: Ident -> Doc
ident  = text . identToLexeme


prettyCTranslationUnit :: CTranslationUnit -> Doc
prettyCTranslationUnit header = pp_Syn_CTranslationUnit synthesized
  where synthesized = wrap_CTranslationUnit (sem_CTranslationUnit header) inherited
        inherited   = Inh_CTranslationUnit
          
}  